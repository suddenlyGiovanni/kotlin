/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.standalone.fir.test.cases.generated.cases.components.resolver;

import com.intellij.testFramework.TestDataPath;
import org.jetbrains.kotlin.test.util.KtTestUtil;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.kotlin.analysis.api.standalone.fir.test.configurators.AnalysisApiFirStandaloneModeTestConfiguratorFactory;
import org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestConfiguratorFactoryData;
import org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiTestConfigurator;
import org.jetbrains.kotlin.analysis.test.framework.test.configurators.TestModuleKind;
import org.jetbrains.kotlin.analysis.test.framework.test.configurators.FrontendKind;
import org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisSessionMode;
import org.jetbrains.kotlin.analysis.test.framework.test.configurators.AnalysisApiMode;
import org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.resolver.AbstractResolveReferenceByFileTest;
import org.jetbrains.kotlin.test.TestMetadata;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.util.regex.Pattern;

/** This class is generated by {@link org.jetbrains.kotlin.analysis.api.standalone.fir.test.TestGeneratorKt}. DO NOT MODIFY MANUALLY */
@SuppressWarnings("all")
@TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi")
@TestDataPath("$PROJECT_ROOT")
public class FirStandaloneNormalAnalysisSourceModuleResolveReferenceByFileTestGenerated extends AbstractResolveReferenceByFileTest {
  @NotNull
  @Override
  public AnalysisApiTestConfigurator getConfigurator() {
    return AnalysisApiFirStandaloneModeTestConfiguratorFactory.INSTANCE.createConfigurator(
      new AnalysisApiTestConfiguratorFactoryData(
        FrontendKind.Fir,
        TestModuleKind.Source,
        AnalysisSessionMode.Normal,
        AnalysisApiMode.Standalone
      )
    );
  }

  private void run(String fileName) {
    runTest("analysis/analysis-api/testData/components/resolver/allByPsi/" + fileName);
  }

  @Test
  public void testAllFilesPresentInAllByPsi() {
    KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi"), Pattern.compile("^(.+)\\.kt$"), null, true);
  }

  @Test
  @TestMetadata("annotatedClasses.kt")
  public void testAnnotatedClasses() {
    run("annotatedClasses.kt");
  }

  @Test
  @TestMetadata("annotatedExpressions.kt")
  public void testAnnotatedExpressions() {
    run("annotatedExpressions.kt");
  }

  @Test
  @TestMetadata("annotatedFunction.kt")
  public void testAnnotatedFunction() {
    run("annotatedFunction.kt");
  }

  @Test
  @TestMetadata("annotatedProperty.kt")
  public void testAnnotatedProperty() {
    run("annotatedProperty.kt");
  }

  @Test
  @TestMetadata("annotations.kt")
  public void testAnnotations() {
    run("annotations.kt");
  }

  @Test
  @TestMetadata("annotationsWithoutCall.kt")
  public void testAnnotationsWithoutCall() {
    run("annotationsWithoutCall.kt");
  }

  @Test
  @TestMetadata("arrayAccess.kt")
  public void testArrayAccess() {
    run("arrayAccess.kt");
  }

  @Test
  @TestMetadata("callChain.kt")
  public void testCallChain() {
    run("callChain.kt");
  }

  @Test
  @TestMetadata("callableReference.kt")
  public void testCallableReference() {
    run("callableReference.kt");
  }

  @Test
  @TestMetadata("compare.kt")
  public void testCompare() {
    run("compare.kt");
  }

  @Test
  @TestMetadata("constructors.kt")
  public void testConstructors() {
    run("constructors.kt");
  }

  @Test
  @TestMetadata("contains.kt")
  public void testContains() {
    run("contains.kt");
  }

  @Test
  @TestMetadata("contextParameters.kt")
  public void testContextParameters() {
    run("contextParameters.kt");
  }

  @Test
  @TestMetadata("delegatedFieldNestedName.kt")
  public void testDelegatedFieldNestedName() {
    run("delegatedFieldNestedName.kt");
  }

  @Test
  @TestMetadata("delegatedProperty.kt")
  public void testDelegatedProperty() {
    run("delegatedProperty.kt");
  }

  @Test
  @TestMetadata("elvis.kt")
  public void testElvis() {
    run("elvis.kt");
  }

  @Test
  @TestMetadata("enum.kt")
  public void testEnum() {
    run("enum.kt");
  }

  @Test
  @TestMetadata("equals.kt")
  public void testEquals() {
    run("equals.kt");
  }

  @Test
  @TestMetadata("explicitContextArgumentErrorExpression.kt")
  public void testExplicitContextArgumentErrorExpression() {
    run("explicitContextArgumentErrorExpression.kt");
  }

  @Test
  @TestMetadata("explicitContextArguments.kt")
  public void testExplicitContextArguments() {
    run("explicitContextArguments.kt");
  }

  @Test
  @TestMetadata("forWithIterator.kt")
  public void testForWithIterator() {
    run("forWithIterator.kt");
  }

  @Test
  @TestMetadata("forWithRange.kt")
  public void testForWithRange() {
    run("forWithRange.kt");
  }

  @Test
  @TestMetadata("infixFunction.kt")
  public void testInfixFunction() {
    run("infixFunction.kt");
  }

  @Test
  @TestMetadata("innerClass.kt")
  public void testInnerClass() {
    run("innerClass.kt");
  }

  @Test
  @TestMetadata("innerClassThis.kt")
  public void testInnerClassThis() {
    run("innerClassThis.kt");
  }

  @Test
  @TestMetadata("invoke.kt")
  public void testInvoke() {
    run("invoke.kt");
  }

  @Test
  @TestMetadata("labels.kt")
  public void testLabels() {
    run("labels.kt");
  }

  @Test
  @TestMetadata("lambdaParameters.kt")
  public void testLambdaParameters() {
    run("lambdaParameters.kt");
  }

  @Test
  @TestMetadata("multiEquals.kt")
  public void testMultiEquals() {
    run("multiEquals.kt");
  }

  @Test
  @TestMetadata("nestedClass.kt")
  public void testNestedClass() {
    run("nestedClass.kt");
  }

  @Test
  @TestMetadata("nestedClassThis.kt")
  public void testNestedClassThis() {
    run("nestedClassThis.kt");
  }

  @Test
  @TestMetadata("operatorsWithContextParameters.kt")
  public void testOperatorsWithContextParameters() {
    run("operatorsWithContextParameters.kt");
  }

  @Test
  @TestMetadata("parenthesisedAnnotationCallArguments.kt")
  public void testParenthesisedAnnotationCallArguments() {
    run("parenthesisedAnnotationCallArguments.kt");
  }

  @Test
  @TestMetadata("parenthesisedCallArguments.kt")
  public void testParenthesisedCallArguments() {
    run("parenthesisedCallArguments.kt");
  }

  @Test
  @TestMetadata("parenthesisedDelegatedConstructorCallArguments.kt")
  public void testParenthesisedDelegatedConstructorCallArguments() {
    run("parenthesisedDelegatedConstructorCallArguments.kt");
  }

  @Test
  @TestMetadata("providedDelegate.kt")
  public void testProvidedDelegate() {
    run("providedDelegate.kt");
  }

  @Test
  @TestMetadata("return.kt")
  public void testReturn() {
    run("return.kt");
  }

  @Test
  @TestMetadata("staticImports.kt")
  public void testStaticImports() {
    run("staticImports.kt");
  }

  @Test
  @TestMetadata("stringConcatenation.kt")
  public void testStringConcatenation() {
    run("stringConcatenation.kt");
  }

  @Test
  @TestMetadata("syntheticProperty.kt")
  public void testSyntheticProperty() {
    run("syntheticProperty.kt");
  }

  @Test
  @TestMetadata("this.kt")
  public void testThis() {
    run("this.kt");
  }

  @Test
  @TestMetadata("typeParameters.kt")
  public void testTypeParameters() {
    run("typeParameters.kt");
  }

  @Test
  @TestMetadata("types.kt")
  public void testTypes() {
    run("types.kt");
  }

  @Test
  @TestMetadata("unaryOperators.kt")
  public void testUnaryOperators() {
    run("unaryOperators.kt");
  }

  @Nested
  @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution")
  @TestDataPath("$PROJECT_ROOT")
  public class ContextSensitiveResolution {
    private void run(String fileName) {
      runTest("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/" + fileName);
    }

    @Test
    public void testAllFilesPresentInContextSensitiveResolution() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @Nested
    @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/ambiguity")
    @TestDataPath("$PROJECT_ROOT")
    public class Ambiguity {
      private void run(String fileName) {
        runTest("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/ambiguity/" + fileName);
      }

      @Test
      public void testAllFilesPresentInAmbiguity() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/ambiguity"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("companion.kt")
      public void testCompanion() {
        run("companion.kt");
      }

      @Test
      @TestMetadata("local.kt")
      public void testLocal() {
        run("local.kt");
      }

      @Test
      @TestMetadata("samePackage.kt")
      public void testSamePackage() {
        run("samePackage.kt");
      }

      @Test
      @TestMetadata("starImport.kt")
      public void testStarImport() {
        run("starImport.kt");
      }
    }

    @Nested
    @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/callArgumentPosition")
    @TestDataPath("$PROJECT_ROOT")
    public class CallArgumentPosition {
      private void run(String fileName) {
        runTest("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/callArgumentPosition/" + fileName);
      }

      @Test
      public void testAllFilesPresentInCallArgumentPosition() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/callArgumentPosition"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("ambiguouslyImported.kt")
      public void testAmbiguouslyImported() {
        run("ambiguouslyImported.kt");
      }

      @Test
      @TestMetadata("ambiguouslyImportedInvisible.kt")
      public void testAmbiguouslyImportedInvisible() {
        run("ambiguouslyImportedInvisible.kt");
      }

      @Test
      @TestMetadata("annotationArguments.kt")
      public void testAnnotationArguments() {
        run("annotationArguments.kt");
      }

      @Test
      @TestMetadata("anonymousFun.kt")
      public void testAnonymousFun() {
        run("anonymousFun.kt");
      }

      @Test
      @TestMetadata("bound.kt")
      public void testBound() {
        run("bound.kt");
      }

      @Test
      @TestMetadata("contextParameters.kt")
      public void testContextParameters() {
        run("contextParameters.kt");
      }

      @Test
      @TestMetadata("defaultArg.kt")
      public void testDefaultArg() {
        run("defaultArg.kt");
      }

      @Test
      @TestMetadata("expectedType.kt")
      public void testExpectedType() {
        run("expectedType.kt");
      }

      @Test
      @TestMetadata("expectedTypeEnum.kt")
      public void testExpectedTypeEnum() {
        run("expectedTypeEnum.kt");
      }

      @Test
      @TestMetadata("generic.kt")
      public void testGeneric() {
        run("generic.kt");
      }

      @Test
      @TestMetadata("infixFun.kt")
      public void testInfixFun() {
        run("infixFun.kt");
      }

      @Test
      @TestMetadata("invisibleImported.kt")
      public void testInvisibleImported() {
        run("invisibleImported.kt");
      }

      @Test
      @TestMetadata("lambda.kt")
      public void testLambda() {
        run("lambda.kt");
      }

      @Test
      @TestMetadata("lambdaEnum.kt")
      public void testLambdaEnum() {
        run("lambdaEnum.kt");
      }

      @Test
      @TestMetadata("lambdaReceiver.kt")
      public void testLambdaReceiver() {
        run("lambdaReceiver.kt");
      }

      @Test
      @TestMetadata("lambdaReceiverParametrized.kt")
      public void testLambdaReceiverParametrized() {
        run("lambdaReceiverParametrized.kt");
      }

      @Test
      @TestMetadata("multipleOverloads.kt")
      public void testMultipleOverloads() {
        run("multipleOverloads.kt");
      }

      @Test
      @TestMetadata("namedArg.kt")
      public void testNamedArg() {
        run("namedArg.kt");
      }

      @Test
      @TestMetadata("noContextSensitiveResolutionShouldHappen.kt")
      public void testNoContextSensitiveResolutionShouldHappen() {
        run("noContextSensitiveResolutionShouldHappen.kt");
      }

      @Test
      @TestMetadata("nonEnums.kt")
      public void testNonEnums() {
        run("nonEnums.kt");
      }

      @Test
      @TestMetadata("operatorOverload.kt")
      public void testOperatorOverload() {
        run("operatorOverload.kt");
      }

      @Test
      @TestMetadata("overload.kt")
      public void testOverload() {
        run("overload.kt");
      }

      @Test
      @TestMetadata("pcla.kt")
      public void testPcla() {
        run("pcla.kt");
      }

      @Test
      @TestMetadata("regularArg.kt")
      public void testRegularArg() {
        run("regularArg.kt");
      }

      @Test
      @TestMetadata("regularArgEnum.kt")
      public void testRegularArgEnum() {
        run("regularArgEnum.kt");
      }

      @Test
      @TestMetadata("simple.kt")
      public void testSimple() {
        run("simple.kt");
      }

      @Test
      @TestMetadata("simpleDisabledFeature.kt")
      public void testSimpleDisabledFeature() {
        run("simpleDisabledFeature.kt");
      }

      @Test
      @TestMetadata("simpleGeneric.kt")
      public void testSimpleGeneric() {
        run("simpleGeneric.kt");
      }

      @Test
      @TestMetadata("simpleVarargs.kt")
      public void testSimpleVarargs() {
        run("simpleVarargs.kt");
      }

      @Test
      @TestMetadata("varargs.kt")
      public void testVarargs() {
        run("varargs.kt");
      }
    }

    @Nested
    @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/nestedInheritors")
    @TestDataPath("$PROJECT_ROOT")
    public class NestedInheritors {
      private void run(String fileName) {
        runTest("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/nestedInheritors/" + fileName);
      }

      @Test
      public void testAllFilesPresentInNestedInheritors() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/nestedInheritors"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("equality.kt")
      public void testEquality() {
        run("equality.kt");
      }

      @Test
      @TestMetadata("guard.kt")
      public void testGuard() {
        run("guard.kt");
      }

      @Test
      @TestMetadata("inWhen.kt")
      public void testInWhen() {
        run("inWhen.kt");
      }

      @Test
      @TestMetadata("negatedIs.kt")
      public void testNegatedIs() {
        run("negatedIs.kt");
      }

      @Test
      @TestMetadata("property.kt")
      public void testProperty() {
        run("property.kt");
      }
    }

    @Nested
    @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/otherExpectedTypePositions")
    @TestDataPath("$PROJECT_ROOT")
    public class OtherExpectedTypePositions {
      private void run(String fileName) {
        runTest("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/otherExpectedTypePositions/" + fileName);
      }

      @Test
      public void testAllFilesPresentInOtherExpectedTypePositions() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/otherExpectedTypePositions"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("basicExampleWithEnumAndWhens.kt")
      public void testBasicExampleWithEnumAndWhens() {
        run("basicExampleWithEnumAndWhens.kt");
      }

      @Test
      @TestMetadata("differentTrivialExpectedTypeMismatch.kt")
      public void testDifferentTrivialExpectedTypeMismatch() {
        run("differentTrivialExpectedTypeMismatch.kt");
      }

      @Test
      @TestMetadata("differentTrivialExpectedTypePositions.kt")
      public void testDifferentTrivialExpectedTypePositions() {
        run("differentTrivialExpectedTypePositions.kt");
      }

      @Test
      @TestMetadata("elvisOperator.kt")
      public void testElvisOperator() {
        run("elvisOperator.kt");
      }

      @Test
      @TestMetadata("elvisOperatorEnum.kt")
      public void testElvisOperatorEnum() {
        run("elvisOperatorEnum.kt");
      }

      @Test
      @TestMetadata("equalityOperator.kt")
      public void testEqualityOperator() {
        run("equalityOperator.kt");
      }

      @Test
      @TestMetadata("equalityOperatorOnBoundedEnumTypeParameter.kt")
      public void testEqualityOperatorOnBoundedEnumTypeParameter() {
        run("equalityOperatorOnBoundedEnumTypeParameter.kt");
      }

      @Test
      @TestMetadata("equalityOperatorOnBoundedSealedTypeParameter.kt")
      public void testEqualityOperatorOnBoundedSealedTypeParameter() {
        run("equalityOperatorOnBoundedSealedTypeParameter.kt");
      }

      @Test
      @TestMetadata("explicitReturnTypes.kt")
      public void testExplicitReturnTypes() {
        run("explicitReturnTypes.kt");
      }

      @Test
      @TestMetadata("extensions.kt")
      public void testExtensions() {
        run("extensions.kt");
      }

      @Test
      @TestMetadata("functionalTypes.kt")
      public void testFunctionalTypes() {
        run("functionalTypes.kt");
      }

      @Test
      @TestMetadata("lambdasReturnStatements.kt")
      public void testLambdasReturnStatements() {
        run("lambdasReturnStatements.kt");
      }

      @Test
      @TestMetadata("lambdasReturnStatementsWithResolvedQualifiers.kt")
      public void testLambdasReturnStatementsWithResolvedQualifiers() {
        run("lambdasReturnStatementsWithResolvedQualifiers.kt");
      }

      @Test
      @TestMetadata("notNullAssertion.kt")
      public void testNotNullAssertion() {
        run("notNullAssertion.kt");
      }

      @Test
      @TestMetadata("notNullAssertionEnum.kt")
      public void testNotNullAssertionEnum() {
        run("notNullAssertionEnum.kt");
      }

      @Test
      @TestMetadata("propInitializers.kt")
      public void testPropInitializers() {
        run("propInitializers.kt");
      }

      @Test
      @TestMetadata("sameNamedEnumEntry.kt")
      public void testSameNamedEnumEntry() {
        run("sameNamedEnumEntry.kt");
      }

      @Test
      @TestMetadata("simple.kt")
      public void testSimple() {
        run("simple.kt");
      }

      @Test
      @TestMetadata("simpleDisabledFeature.kt")
      public void testSimpleDisabledFeature() {
        run("simpleDisabledFeature.kt");
      }

      @Test
      @TestMetadata("tryCatchStatements.kt")
      public void testTryCatchStatements() {
        run("tryCatchStatements.kt");
      }

      @Test
      @TestMetadata("tryCatchStatementsEnum.kt")
      public void testTryCatchStatementsEnum() {
        run("tryCatchStatementsEnum.kt");
      }

      @Test
      @TestMetadata("whenIfLastStatement.kt")
      public void testWhenIfLastStatement() {
        run("whenIfLastStatement.kt");
      }

      @Test
      @TestMetadata("whenIfLastStatementEnum.kt")
      public void testWhenIfLastStatementEnum() {
        run("whenIfLastStatementEnum.kt");
      }
    }

    @Nested
    @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/typePosition")
    @TestDataPath("$PROJECT_ROOT")
    public class TypePosition {
      private void run(String fileName) {
        runTest("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/typePosition/" + fileName);
      }

      @Test
      public void testAllFilesPresentInTypePosition() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/typePosition"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("ambiguouslyImported.kt")
      public void testAmbiguouslyImported() {
        run("ambiguouslyImported.kt");
      }

      @Test
      @TestMetadata("ambiguouslyImportedInvisible.kt")
      public void testAmbiguouslyImportedInvisible() {
        run("ambiguouslyImportedInvisible.kt");
      }

      @Test
      @TestMetadata("either.kt")
      public void testEither() {
        run("either.kt");
      }

      @Test
      @TestMetadata("eitherInDifferentPositions.kt")
      public void testEitherInDifferentPositions() {
        run("eitherInDifferentPositions.kt");
      }

      @Test
      @TestMetadata("innerClassInGeneric.kt")
      public void testInnerClassInGeneric() {
        run("innerClassInGeneric.kt");
      }

      @Test
      @TestMetadata("invisibleImported.kt")
      public void testInvisibleImported() {
        run("invisibleImported.kt");
      }

      @Test
      @TestMetadata("isInIf.kt")
      public void testIsInIf() {
        run("isInIf.kt");
      }

      @Test
      @TestMetadata("isInWhen.kt")
      public void testIsInWhen() {
        run("isInWhen.kt");
      }

      @Test
      @TestMetadata("javaInterop.kt")
      public void testJavaInterop() {
        run("javaInterop.kt");
      }

      @Test
      @TestMetadata("nonSealed.kt")
      public void testNonSealed() {
        run("nonSealed.kt");
      }

      @Test
      @TestMetadata("nonTrivialTypes.kt")
      public void testNonTrivialTypes() {
        run("nonTrivialTypes.kt");
      }

      @Test
      @TestMetadata("regularlyResolved.kt")
      public void testRegularlyResolved() {
        run("regularlyResolved.kt");
      }

      @Test
      @TestMetadata("regularlyResolvedNoGenericArgument.kt")
      public void testRegularlyResolvedNoGenericArgument() {
        run("regularlyResolvedNoGenericArgument.kt");
      }

      @Test
      @TestMetadata("sealedWithNonSealedSubclass.kt")
      public void testSealedWithNonSealedSubclass() {
        run("sealedWithNonSealedSubclass.kt");
      }

      @Test
      @TestMetadata("simple.kt")
      public void testSimple() {
        run("simple.kt");
      }

      @Test
      @TestMetadata("simpleDisabledFeature.kt")
      public void testSimpleDisabledFeature() {
        run("simpleDisabledFeature.kt");
      }

      @Test
      @TestMetadata("singleDefiniteExpectedType.kt")
      public void testSingleDefiniteExpectedType() {
        run("singleDefiniteExpectedType.kt");
      }

      @Test
      @TestMetadata("typeCast.kt")
      public void testTypeCast() {
        run("typeCast.kt");
      }

      @Test
      @TestMetadata("typeParameter.kt")
      public void testTypeParameter() {
        run("typeParameter.kt");
      }

      @Test
      @TestMetadata("typeParametersComplex.kt")
      public void testTypeParametersComplex() {
        run("typeParametersComplex.kt");
      }

      @Test
      @TestMetadata("unsupportedTypePosition.kt")
      public void testUnsupportedTypePosition() {
        run("unsupportedTypePosition.kt");
      }
    }

    @Nested
    @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/unqualifiedEnum")
    @TestDataPath("$PROJECT_ROOT")
    public class UnqualifiedEnum {
      private void run(String fileName) {
        runTest("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/unqualifiedEnum/" + fileName);
      }

      @Test
      public void testAllFilesPresentInUnqualifiedEnum() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/contextSensitiveResolution/unqualifiedEnum"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("correctJava.kt")
      public void testCorrectJava() {
        run("correctJava.kt");
      }

      @Test
      @TestMetadata("enumWithTheSameNameAsEntry.kt")
      public void testEnumWithTheSameNameAsEntry() {
        run("enumWithTheSameNameAsEntry.kt");
      }

      @Test
      @TestMetadata("incorrectJava.kt")
      public void testIncorrectJava() {
        run("incorrectJava.kt");
      }

      @Test
      @TestMetadata("nested.kt")
      public void testNested() {
        run("nested.kt");
      }

      @Test
      @TestMetadata("notInsideBranches.kt")
      public void testNotInsideBranches() {
        run("notInsideBranches.kt");
      }

      @Test
      @TestMetadata("priority.kt")
      public void testPriority() {
        run("priority.kt");
      }

      @Test
      @TestMetadata("typeAlias.kt")
      public void testTypeAlias() {
        run("typeAlias.kt");
      }

      @Test
      @TestMetadata("unqualifiedEnum.kt")
      public void testUnqualifiedEnum() {
        run("unqualifiedEnum.kt");
      }
    }
  }

  @Nested
  @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/destructuring")
  @TestDataPath("$PROJECT_ROOT")
  public class Destructuring {
    private void run(String fileName) {
      runTest("analysis/analysis-api/testData/components/resolver/allByPsi/destructuring/" + fileName);
    }

    @Test
    public void testAllFilesPresentInDestructuring() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/destructuring"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("nameBasedDestructuringFullForm.kt")
    public void testNameBasedDestructuringFullForm() {
      run("nameBasedDestructuringFullForm.kt");
    }

    @Test
    @TestMetadata("nameBasedDestructuringFullFormErrors.kt")
    public void testNameBasedDestructuringFullFormErrors() {
      run("nameBasedDestructuringFullFormErrors.kt");
    }

    @Test
    @TestMetadata("nameBasedDestructuringShortFormAfter.kt")
    public void testNameBasedDestructuringShortFormAfter() {
      run("nameBasedDestructuringShortFormAfter.kt");
    }

    @Test
    @TestMetadata("nameBasedDestructuringShortFormErrorsAfter.kt")
    public void testNameBasedDestructuringShortFormErrorsAfter() {
      run("nameBasedDestructuringShortFormErrorsAfter.kt");
    }

    @Test
    @TestMetadata("positionalDestructuringFullForm.kt")
    public void testPositionalDestructuringFullForm() {
      run("positionalDestructuringFullForm.kt");
    }

    @Test
    @TestMetadata("positionalDestructuringFullFormErrors.kt")
    public void testPositionalDestructuringFullFormErrors() {
      run("positionalDestructuringFullFormErrors.kt");
    }

    @Test
    @TestMetadata("positionalDestructuringShortForm.kt")
    public void testPositionalDestructuringShortForm() {
      run("positionalDestructuringShortForm.kt");
    }

    @Test
    @TestMetadata("positionalDestructuringShortFormErrors.kt")
    public void testPositionalDestructuringShortFormErrors() {
      run("positionalDestructuringShortFormErrors.kt");
    }
  }

  @Nested
  @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/imports")
  @TestDataPath("$PROJECT_ROOT")
  public class Imports {
    private void run(String fileName) {
      runTest("analysis/analysis-api/testData/components/resolver/allByPsi/imports/" + fileName);
    }

    @Test
    public void testAllFilesPresentInImports() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/imports"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("enumEntry.kt")
    public void testEnumEntry() {
      run("enumEntry.kt");
    }

    @Test
    @TestMetadata("javaClass.kt")
    public void testJavaClass() {
      run("javaClass.kt");
    }

    @Test
    @TestMetadata("javaClassWithBaseClass.kt")
    public void testJavaClassWithBaseClass() {
      run("javaClassWithBaseClass.kt");
    }

    @Test
    @TestMetadata("javaClass_rootPackage.kt")
    public void testJavaClass_rootPackage() {
      run("javaClass_rootPackage.kt");
    }

    @Test
    @TestMetadata("simple.kt")
    public void testSimple() {
      run("simple.kt");
    }

    @Test
    @TestMetadata("star.kt")
    public void testStar() {
      run("star.kt");
    }

    @Test
    @TestMetadata("topLevelObject.kt")
    public void testTopLevelObject() {
      run("topLevelObject.kt");
    }

    @Test
    @TestMetadata("topLevelObjectWithBaseClass.kt")
    public void testTopLevelObjectWithBaseClass() {
      run("topLevelObjectWithBaseClass.kt");
    }

    @Test
    @TestMetadata("topLevelObject_rootPackage.kt")
    public void testTopLevelObject_rootPackage() {
      run("topLevelObject_rootPackage.kt");
    }
  }

  @Nested
  @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/typeAlias")
  @TestDataPath("$PROJECT_ROOT")
  public class TypeAlias {
    private void run(String fileName) {
      runTest("analysis/analysis-api/testData/components/resolver/allByPsi/typeAlias/" + fileName);
    }

    @Test
    public void testAllFilesPresentInTypeAlias() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/typeAlias"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("TypeAliasedCompanionObjectAsQualifier.kt")
    public void testTypeAliasedCompanionObjectAsQualifier() {
      run("TypeAliasedCompanionObjectAsQualifier.kt");
    }

    @Test
    @TestMetadata("TypeAliasedObjectAsQualifier.kt")
    public void testTypeAliasedObjectAsQualifier() {
      run("TypeAliasedObjectAsQualifier.kt");
    }
  }

  @Nested
  @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/withErrors")
  @TestDataPath("$PROJECT_ROOT")
  public class WithErrors {
    private void run(String fileName) {
      runTest("analysis/analysis-api/testData/components/resolver/allByPsi/withErrors/" + fileName);
    }

    @Test
    public void testAllFilesPresentInWithErrors() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/withErrors"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("assignOperatorAmbiguity.kt")
    public void testAssignOperatorAmbiguity() {
      run("assignOperatorAmbiguity.kt");
    }

    @Nested
    @TestMetadata("analysis/analysis-api/testData/components/resolver/allByPsi/withErrors/partiallyUnresolvedTypeQualifier")
    @TestDataPath("$PROJECT_ROOT")
    public class PartiallyUnresolvedTypeQualifier {
      private void run(String fileName) {
        runTest("analysis/analysis-api/testData/components/resolver/allByPsi/withErrors/partiallyUnresolvedTypeQualifier/" + fileName);
      }

      @Test
      public void testAllFilesPresentInPartiallyUnresolvedTypeQualifier() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("analysis/analysis-api/testData/components/resolver/allByPsi/withErrors/partiallyUnresolvedTypeQualifier"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("ClassNameBeforeOneUnsresolvedClass.kt")
      public void testClassNameBeforeOneUnsresolvedClass() {
        run("ClassNameBeforeOneUnsresolvedClass.kt");
      }

      @Test
      @TestMetadata("ClassNameBeforeOneUnsresolvedClassWithDot.kt")
      public void testClassNameBeforeOneUnsresolvedClassWithDot() {
        run("ClassNameBeforeOneUnsresolvedClassWithDot.kt");
      }

      @Test
      @TestMetadata("ClassNameBeforeOneUnsresolvedClassWithTwoResolved.kt")
      public void testClassNameBeforeOneUnsresolvedClassWithTwoResolved() {
        run("ClassNameBeforeOneUnsresolvedClassWithTwoResolved.kt");
      }

      @Test
      @TestMetadata("ClassNameBeforeOneUnsresolvedClassWithTwoResolvedWithDot.kt")
      public void testClassNameBeforeOneUnsresolvedClassWithTwoResolvedWithDot() {
        run("ClassNameBeforeOneUnsresolvedClassWithTwoResolvedWithDot.kt");
      }

      @Test
      @TestMetadata("ClassNameBeforeTwoUnsresolvedClasses.kt")
      public void testClassNameBeforeTwoUnsresolvedClasses() {
        run("ClassNameBeforeTwoUnsresolvedClasses.kt");
      }

      @Test
      @TestMetadata("ClassNameBeforeTwoUnsresolvedClassesTwoResolved.kt")
      public void testClassNameBeforeTwoUnsresolvedClassesTwoResolved() {
        run("ClassNameBeforeTwoUnsresolvedClassesTwoResolved.kt");
      }

      @Test
      @TestMetadata("ClassNameBeforeTwoUnsresolvedClassesWithDot.kt")
      public void testClassNameBeforeTwoUnsresolvedClassesWithDot() {
        run("ClassNameBeforeTwoUnsresolvedClassesWithDot.kt");
      }

      @Test
      @TestMetadata("GenericClassNameBeforeOneUnresolvedClass.kt")
      public void testGenericClassNameBeforeOneUnresolvedClass() {
        run("GenericClassNameBeforeOneUnresolvedClass.kt");
      }
    }
  }
}
