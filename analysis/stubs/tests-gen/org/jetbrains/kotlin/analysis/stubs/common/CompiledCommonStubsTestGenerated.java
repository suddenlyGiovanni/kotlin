/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.stubs.common;

import com.intellij.testFramework.TestDataPath;
import org.jetbrains.kotlin.test.util.KtTestUtil;
import org.jetbrains.kotlin.test.TestMetadata;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.util.regex.Pattern;

/** This class is generated by {@link org.jetbrains.kotlin.analysis.stubs.TestGeneratorKt}. DO NOT MODIFY MANUALLY */
@SuppressWarnings("all")
@TestMetadata("compiler/testData/psi")
@TestDataPath("$PROJECT_ROOT")
public class CompiledCommonStubsTestGenerated extends AbstractCompiledCommonStubsTest {
  private void run(String fileName) {
    runTest("compiler/testData/psi/" + fileName);
  }

  @Test
  @TestMetadata("AbsentInnerType.kt")
  public void testAbsentInnerType() {
    run("AbsentInnerType.kt");
  }

  @Test
  public void testAllFilesPresentInPsi() {
    KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi"), Pattern.compile("^([^.]+)\\.kt$"), null, true, "k1");
  }

  @Test
  @TestMetadata("annotatedFlexibleTypes.kt")
  public void testAnnotatedFlexibleTypes() {
    run("annotatedFlexibleTypes.kt");
  }

  @Test
  @TestMetadata("AnnotatedIntersections.kt")
  public void testAnnotatedIntersections() {
    run("AnnotatedIntersections.kt");
  }

  @Test
  @TestMetadata("annotatedParameterInEnumConstructor.kt")
  public void testAnnotatedParameterInEnumConstructor() {
    run("annotatedParameterInEnumConstructor.kt");
  }

  @Test
  @TestMetadata("annotatedParameterInInnerClassConstructor.kt")
  public void testAnnotatedParameterInInnerClassConstructor() {
    run("annotatedParameterInInnerClassConstructor.kt");
  }

  @Test
  @TestMetadata("annotationClass.kt")
  public void testAnnotationClass() {
    run("annotationClass.kt");
  }

  @Test
  @TestMetadata("annotationValues.kt")
  public void testAnnotationValues() {
    run("annotationValues.kt");
  }

  @Test
  @TestMetadata("annotations.kt")
  public void testAnnotations() {
    run("annotations.kt");
  }

  @Test
  @TestMetadata("annotationsOnNullableTypes.kt")
  public void testAnnotationsOnNullableTypes() {
    run("annotationsOnNullableTypes.kt");
  }

  @Test
  @TestMetadata("annotationsOnParenthesizedTypes.kt")
  public void testAnnotationsOnParenthesizedTypes() {
    run("annotationsOnParenthesizedTypes.kt");
  }

  @Test
  @TestMetadata("AnonymousInitializer.kt")
  public void testAnonymousInitializer() {
    run("AnonymousInitializer.kt");
  }

  @Test
  @TestMetadata("anonymousReturnWithGenericType.kt")
  public void testAnonymousReturnWithGenericType() {
    run("anonymousReturnWithGenericType.kt");
  }

  @Test
  @TestMetadata("AssertNotNull.kt")
  public void testAssertNotNull() {
    run("AssertNotNull.kt");
  }

  @Test
  @TestMetadata("BabySteps.kt")
  public void testBabySteps() {
    run("BabySteps.kt");
  }

  @Test
  @TestMetadata("BabySteps_ERR.kt")
  public void testBabySteps_ERR() {
    run("BabySteps_ERR.kt");
  }

  @Test
  @TestMetadata("BackslashInString.kt")
  public void testBackslashInString() {
    run("BackslashInString.kt");
  }

  @Test
  @TestMetadata("BlockCommentAtBeginningOfFile1.kt")
  public void testBlockCommentAtBeginningOfFile1() {
    run("BlockCommentAtBeginningOfFile1.kt");
  }

  @Test
  @TestMetadata("BlockCommentAtBeginningOfFile2.kt")
  public void testBlockCommentAtBeginningOfFile2() {
    run("BlockCommentAtBeginningOfFile2.kt");
  }

  @Test
  @TestMetadata("BlockCommentAtBeginningOfFile3.kt")
  public void testBlockCommentAtBeginningOfFile3() {
    run("BlockCommentAtBeginningOfFile3.kt");
  }

  @Test
  @TestMetadata("BlockCommentAtBeginningOfFile4.kt")
  public void testBlockCommentAtBeginningOfFile4() {
    run("BlockCommentAtBeginningOfFile4.kt");
  }

  @Test
  @TestMetadata("BlockCommentUnmatchedClosing_ERR.kt")
  public void testBlockCommentUnmatchedClosing_ERR() {
    run("BlockCommentUnmatchedClosing_ERR.kt");
  }

  @Test
  @TestMetadata("ByClauses.kt")
  public void testByClauses() {
    run("ByClauses.kt");
  }

  @Test
  @TestMetadata("CallWithManyClosures.kt")
  public void testCallWithManyClosures() {
    run("CallWithManyClosures.kt");
  }

  @Test
  @TestMetadata("CallsInWhen.kt")
  public void testCallsInWhen() {
    run("CallsInWhen.kt");
  }

  @Test
  @TestMetadata("classMembers.kt")
  public void testClassMembers() {
    run("classMembers.kt");
  }

  @Test
  @TestMetadata("classObject.kt")
  public void testClassObject() {
    run("classObject.kt");
  }

  @Test
  @TestMetadata("CollectionLiterals.kt")
  public void testCollectionLiterals() {
    run("CollectionLiterals.kt");
  }

  @Test
  @TestMetadata("CollectionLiterals_ERR.kt")
  public void testCollectionLiterals_ERR() {
    run("CollectionLiterals_ERR.kt");
  }

  @Test
  @TestMetadata("CommentsBinding.kt")
  public void testCommentsBinding() {
    run("CommentsBinding.kt");
  }

  @Test
  @TestMetadata("CommentsBindingInLambda.kt")
  public void testCommentsBindingInLambda() {
    run("CommentsBindingInLambda.kt");
  }

  @Test
  @TestMetadata("CommentsBindingInStatementBlock.kt")
  public void testCommentsBindingInStatementBlock() {
    run("CommentsBindingInStatementBlock.kt");
  }

  @Test
  @TestMetadata("complicateLTGT.kt")
  public void testComplicateLTGT() {
    run("complicateLTGT.kt");
  }

  @Test
  @TestMetadata("complicateLTGTE.kt")
  public void testComplicateLTGTE() {
    run("complicateLTGTE.kt");
  }

  @Test
  @TestMetadata("const.kt")
  public void testConst() {
    run("const.kt");
  }

  @Test
  @TestMetadata("Constructors.kt")
  public void testConstructors() {
    run("Constructors.kt");
  }

  @Test
  @TestMetadata("contextParametersAndAnnotations.kt")
  public void testContextParametersAndAnnotations() {
    run("contextParametersAndAnnotations.kt");
  }

  @Test
  @TestMetadata("ControlStructures.kt")
  public void testControlStructures() {
    run("ControlStructures.kt");
  }

  @Test
  @TestMetadata("dataClass.kt")
  public void testDataClass() {
    run("dataClass.kt");
  }

  @Test
  @TestMetadata("dataObject.kt")
  public void testDataObject() {
    run("dataObject.kt");
  }

  @Test
  @TestMetadata("defaultImplsInInterface.kt")
  public void testDefaultImplsInInterface() {
    run("defaultImplsInInterface.kt");
  }

  @Test
  @TestMetadata("DefaultKeyword.kt")
  public void testDefaultKeyword() {
    run("DefaultKeyword.kt");
  }

  @Test
  @TestMetadata("DefinitelyNotNullType.kt")
  public void testDefinitelyNotNullType() {
    run("DefinitelyNotNullType.kt");
  }

  @Test
  @TestMetadata("definitelyNotNullTypes.kt")
  public void testDefinitelyNotNullTypes() {
    run("definitelyNotNullTypes.kt");
  }

  @Test
  @TestMetadata("delegatedWithInitializer.kt")
  public void testDelegatedWithInitializer() {
    run("delegatedWithInitializer.kt");
  }

  @Test
  @TestMetadata("delegation.kt")
  public void testDelegation() {
    run("delegation.kt");
  }

  @Test
  @TestMetadata("dependencyOnNestedClasses.kt")
  public void testDependencyOnNestedClasses() {
    run("dependencyOnNestedClasses.kt");
  }

  @Test
  @TestMetadata("destructuringInLambdas.kt")
  public void testDestructuringInLambdas() {
    run("destructuringInLambdas.kt");
  }

  @Test
  @TestMetadata("destructuringInLambdas_ERR.kt")
  public void testDestructuringInLambdas_ERR() {
    run("destructuringInLambdas_ERR.kt");
  }

  @Test
  @TestMetadata("diagnosticTags_ERR.kt")
  public void testDiagnosticTags_ERR() {
    run("diagnosticTags_ERR.kt");
  }

  @Test
  @TestMetadata("DocCommentAfterFileAnnotations.kt")
  public void testDocCommentAfterFileAnnotations() {
    run("DocCommentAfterFileAnnotations.kt");
  }

  @Test
  @TestMetadata("DocCommentForFirstDeclaration.kt")
  public void testDocCommentForFirstDeclaration() {
    run("DocCommentForFirstDeclaration.kt");
  }

  @Test
  @TestMetadata("DocCommentOnPackageDirectiveLine.kt")
  public void testDocCommentOnPackageDirectiveLine() {
    run("DocCommentOnPackageDirectiveLine.kt");
  }

  @Test
  @TestMetadata("DocCommentsBinding.kt")
  public void testDocCommentsBinding() {
    run("DocCommentsBinding.kt");
  }

  @Test
  @TestMetadata("DoubleColon.kt")
  public void testDoubleColon() {
    run("DoubleColon.kt");
  }

  @Test
  @TestMetadata("DoubleColonWhitespaces.kt")
  public void testDoubleColonWhitespaces() {
    run("DoubleColonWhitespaces.kt");
  }

  @Test
  @TestMetadata("DoubleColon_ERR.kt")
  public void testDoubleColon_ERR() {
    run("DoubleColon_ERR.kt");
  }

  @Test
  @TestMetadata("DuplicateAccessor.kt")
  public void testDuplicateAccessor() {
    run("DuplicateAccessor.kt");
  }

  @Test
  @TestMetadata("DynamicReceiver.kt")
  public void testDynamicReceiver() {
    run("DynamicReceiver.kt");
  }

  @Test
  @TestMetadata("DynamicSoftKeyword.kt")
  public void testDynamicSoftKeyword() {
    run("DynamicSoftKeyword.kt");
  }

  @Test
  @TestMetadata("DynamicTypes.kt")
  public void testDynamicTypes() {
    run("DynamicTypes.kt");
  }

  @Test
  @TestMetadata("EOLsInComments.kt")
  public void testEOLsInComments() {
    run("EOLsInComments.kt");
  }

  @Test
  @TestMetadata("EOLsOnRollback.kt")
  public void testEOLsOnRollback() {
    run("EOLsOnRollback.kt");
  }

  @Test
  @TestMetadata("emptyArguments.kt")
  public void testEmptyArguments() {
    run("emptyArguments.kt");
  }

  @Test
  @TestMetadata("emptyArgumentsInAnnotations.kt")
  public void testEmptyArgumentsInAnnotations() {
    run("emptyArgumentsInAnnotations.kt");
  }

  @Test
  @TestMetadata("emptyArgumentsInArrayAccesses.kt")
  public void testEmptyArgumentsInArrayAccesses() {
    run("emptyArgumentsInArrayAccesses.kt");
  }

  @Test
  @TestMetadata("emptyContextParameters.kt")
  public void testEmptyContextParameters() {
    run("emptyContextParameters.kt");
  }

  @Test
  @TestMetadata("emptyEnum.kt")
  public void testEmptyEnum() {
    run("emptyEnum.kt");
  }

  @Test
  @TestMetadata("EmptyFile.kt")
  public void testEmptyFile() {
    run("EmptyFile.kt");
  }

  @Test
  @TestMetadata("EmptyName.kt")
  public void testEmptyName() {
    run("EmptyName.kt");
  }

  @Test
  @TestMetadata("emptyParameters.kt")
  public void testEmptyParameters() {
    run("emptyParameters.kt");
  }

  @Test
  @TestMetadata("emptyParametersInFunctionalTypes.kt")
  public void testEmptyParametersInFunctionalTypes() {
    run("emptyParametersInFunctionalTypes.kt");
  }

  @Test
  @TestMetadata("enum.kt")
  public void testEnum() {
    run("enum.kt");
  }

  @Test
  @TestMetadata("EnumCommas.kt")
  public void testEnumCommas() {
    run("EnumCommas.kt");
  }

  @Test
  @TestMetadata("EnumEntryCommaAnnotatedMember.kt")
  public void testEnumEntryCommaAnnotatedMember() {
    run("EnumEntryCommaAnnotatedMember.kt");
  }

  @Test
  @TestMetadata("EnumEntryCommaInlineMember.kt")
  public void testEnumEntryCommaInlineMember() {
    run("EnumEntryCommaInlineMember.kt");
  }

  @Test
  @TestMetadata("EnumEntryCommaMember.kt")
  public void testEnumEntryCommaMember() {
    run("EnumEntryCommaMember.kt");
  }

  @Test
  @TestMetadata("EnumEntryCommaPublicMember.kt")
  public void testEnumEntryCommaPublicMember() {
    run("EnumEntryCommaPublicMember.kt");
  }

  @Test
  @TestMetadata("enumEntryContent.kt")
  public void testEnumEntryContent() {
    run("enumEntryContent.kt");
  }

  @Test
  @TestMetadata("EnumEntrySemicolonInlineMember.kt")
  public void testEnumEntrySemicolonInlineMember() {
    run("EnumEntrySemicolonInlineMember.kt");
  }

  @Test
  @TestMetadata("EnumEntrySemicolonMember.kt")
  public void testEnumEntrySemicolonMember() {
    run("EnumEntrySemicolonMember.kt");
  }

  @Test
  @TestMetadata("EnumEntrySpaceInlineMember.kt")
  public void testEnumEntrySpaceInlineMember() {
    run("EnumEntrySpaceInlineMember.kt");
  }

  @Test
  @TestMetadata("EnumEntrySpaceMember.kt")
  public void testEnumEntrySpaceMember() {
    run("EnumEntrySpaceMember.kt");
  }

  @Test
  @TestMetadata("EnumEntryTwoCommas.kt")
  public void testEnumEntryTwoCommas() {
    run("EnumEntryTwoCommas.kt");
  }

  @Test
  @TestMetadata("EnumIn.kt")
  public void testEnumIn() {
    run("EnumIn.kt");
  }

  @Test
  @TestMetadata("EnumInline.kt")
  public void testEnumInline() {
    run("EnumInline.kt");
  }

  @Test
  @TestMetadata("EnumInlinePublic.kt")
  public void testEnumInlinePublic() {
    run("EnumInlinePublic.kt");
  }

  @Test
  @TestMetadata("EnumMissingName.kt")
  public void testEnumMissingName() {
    run("EnumMissingName.kt");
  }

  @Test
  @TestMetadata("EnumOldConstructorSyntax.kt")
  public void testEnumOldConstructorSyntax() {
    run("EnumOldConstructorSyntax.kt");
  }

  @Test
  @TestMetadata("EnumShortCommas.kt")
  public void testEnumShortCommas() {
    run("EnumShortCommas.kt");
  }

  @Test
  @TestMetadata("EnumShortWithOverload.kt")
  public void testEnumShortWithOverload() {
    run("EnumShortWithOverload.kt");
  }

  @Test
  @TestMetadata("EnumWithAnnotationKeyword.kt")
  public void testEnumWithAnnotationKeyword() {
    run("EnumWithAnnotationKeyword.kt");
  }

  @Test
  @TestMetadata("Enums.kt")
  public void testEnums() {
    run("Enums.kt");
  }

  @Test
  @TestMetadata("escapedNames.kt")
  public void testEscapedNames() {
    run("escapedNames.kt");
  }

  @Test
  @TestMetadata("Expressions_ERR.kt")
  public void testExpressions_ERR() {
    run("Expressions_ERR.kt");
  }

  @Test
  @TestMetadata("ExtensionsWithQNReceiver.kt")
  public void testExtensionsWithQNReceiver() {
    run("ExtensionsWithQNReceiver.kt");
  }

  @Test
  @TestMetadata("FileStart_ERR.kt")
  public void testFileStart_ERR() {
    run("FileStart_ERR.kt");
  }

  @Test
  @TestMetadata("flexibleDnnType.kt")
  public void testFlexibleDnnType() {
    run("flexibleDnnType.kt");
  }

  @Test
  @TestMetadata("FloatingPointLiteral.kt")
  public void testFloatingPointLiteral() {
    run("FloatingPointLiteral.kt");
  }

  @Test
  @TestMetadata("ForWithMultiDecl.kt")
  public void testForWithMultiDecl() {
    run("ForWithMultiDecl.kt");
  }

  @Test
  @TestMetadata("funInterfaceDeclaration.kt")
  public void testFunInterfaceDeclaration() {
    run("funInterfaceDeclaration.kt");
  }

  @Test
  @TestMetadata("FunctionCalls.kt")
  public void testFunctionCalls() {
    run("FunctionCalls.kt");
  }

  @Test
  @TestMetadata("FunctionExpressions.kt")
  public void testFunctionExpressions() {
    run("FunctionExpressions.kt");
  }

  @Test
  @TestMetadata("FunctionExpressions_ERR.kt")
  public void testFunctionExpressions_ERR() {
    run("FunctionExpressions_ERR.kt");
  }

  @Test
  @TestMetadata("FunctionLiterals.kt")
  public void testFunctionLiterals() {
    run("FunctionLiterals.kt");
  }

  @Test
  @TestMetadata("FunctionLiterals_ERR.kt")
  public void testFunctionLiterals_ERR() {
    run("FunctionLiterals_ERR.kt");
  }

  @Test
  @TestMetadata("FunctionNoParameterList.kt")
  public void testFunctionNoParameterList() {
    run("FunctionNoParameterList.kt");
  }

  @Test
  @TestMetadata("FunctionTypes.kt")
  public void testFunctionTypes() {
    run("FunctionTypes.kt");
  }

  @Test
  @TestMetadata("Functions.kt")
  public void testFunctions() {
    run("Functions.kt");
  }

  @Test
  @TestMetadata("FunctionsWithoutName.kt")
  public void testFunctionsWithoutName() {
    run("FunctionsWithoutName.kt");
  }

  @Test
  @TestMetadata("FunctionsWithoutName_ERR.kt")
  public void testFunctionsWithoutName_ERR() {
    run("FunctionsWithoutName_ERR.kt");
  }

  @Test
  @TestMetadata("Functions_ERR.kt")
  public void testFunctions_ERR() {
    run("Functions_ERR.kt");
  }

  @Test
  @TestMetadata("HangOnLonelyModifier.kt")
  public void testHangOnLonelyModifier() {
    run("HangOnLonelyModifier.kt");
  }

  @Test
  @TestMetadata("IfWithPropery.kt")
  public void testIfWithPropery() {
    run("IfWithPropery.kt");
  }

  @Test
  @TestMetadata("ImportSoftKW.kt")
  public void testImportSoftKW() {
    run("ImportSoftKW.kt");
  }

  @Test
  @TestMetadata("Imports.kt")
  public void testImports() {
    run("Imports.kt");
  }

  @Test
  @TestMetadata("Imports_ERR.kt")
  public void testImports_ERR() {
    run("Imports_ERR.kt");
  }

  @Test
  @TestMetadata("IncompleteFunctionLiteral.kt")
  public void testIncompleteFunctionLiteral() {
    run("IncompleteFunctionLiteral.kt");
  }

  @Test
  @TestMetadata("incorrectLTGTFallback.kt")
  public void testIncorrectLTGTFallback() {
    run("incorrectLTGTFallback.kt");
  }

  @Test
  @TestMetadata("inheritingClasses.kt")
  public void testInheritingClasses() {
    run("inheritingClasses.kt");
  }

  @Test
  @TestMetadata("Inner.kt")
  public void testInner() {
    run("Inner.kt");
  }

  @Test
  @TestMetadata("innerClassEnumEntry.kt")
  public void testInnerClassEnumEntry() {
    run("innerClassEnumEntry.kt");
  }

  @Test
  @TestMetadata("innerTypes.kt")
  public void testInnerTypes() {
    run("innerTypes.kt");
  }

  @Test
  @TestMetadata("IntegerLiteral.kt")
  public void testIntegerLiteral() {
    run("IntegerLiteral.kt");
  }

  @Test
  @TestMetadata("Interface.kt")
  public void testInterface() {
    run("Interface.kt");
  }

  @Test
  @TestMetadata("InterfaceWithEnumKeyword.kt")
  public void testInterfaceWithEnumKeyword() {
    run("InterfaceWithEnumKeyword.kt");
  }

  @Test
  @TestMetadata("internalConst.kt")
  public void testInternalConst() {
    run("internalConst.kt");
  }

  @Test
  @TestMetadata("kotlinFunInterface_ERR.kt")
  public void testKotlinFunInterface_ERR() {
    run("kotlinFunInterface_ERR.kt");
  }

  @Test
  @TestMetadata("Labels.kt")
  public void testLabels() {
    run("Labels.kt");
  }

  @Test
  @TestMetadata("LineCommentAfterFileAnnotations.kt")
  public void testLineCommentAfterFileAnnotations() {
    run("LineCommentAfterFileAnnotations.kt");
  }

  @Test
  @TestMetadata("LineCommentForFirstDeclaration.kt")
  public void testLineCommentForFirstDeclaration() {
    run("LineCommentForFirstDeclaration.kt");
  }

  @Test
  @TestMetadata("LineCommentsInBlock.kt")
  public void testLineCommentsInBlock() {
    run("LineCommentsInBlock.kt");
  }

  @Test
  @TestMetadata("localClass.kt")
  public void testLocalClass() {
    run("localClass.kt");
  }

  @Test
  @TestMetadata("LocalDeclarations.kt")
  public void testLocalDeclarations() {
    run("LocalDeclarations.kt");
  }

  @Test
  @TestMetadata("LongPackageName.kt")
  public void testLongPackageName() {
    run("LongPackageName.kt");
  }

  @Test
  @TestMetadata("ModifierAsSelector.kt")
  public void testModifierAsSelector() {
    run("ModifierAsSelector.kt");
  }

  @Test
  @TestMetadata("modifiers.kt")
  public void testModifiers() {
    run("modifiers.kt");
  }

  @Test
  @TestMetadata("MultiVariableDeclarations.kt")
  public void testMultiVariableDeclarations() {
    run("MultiVariableDeclarations.kt");
  }

  @Test
  @TestMetadata("multifileClass.kt")
  public void testMultifileClass() {
    run("multifileClass.kt");
  }

  @Test
  @TestMetadata("multifileClass2.kt")
  public void testMultifileClass2() {
    run("multifileClass2.kt");
  }

  @Test
  @TestMetadata("mustUseReturnValueAndOverrides.kt")
  public void testMustUseReturnValueAndOverrides() {
    run("mustUseReturnValueAndOverrides.kt");
  }

  @Test
  @TestMetadata("mustUseReturnValueFullEnabled.kt")
  public void testMustUseReturnValueFullEnabled() {
    run("mustUseReturnValueFullEnabled.kt");
  }

  @Test
  @TestMetadata("mustUseReturnValueHalfEnabled.kt")
  public void testMustUseReturnValueHalfEnabled() {
    run("mustUseReturnValueHalfEnabled.kt");
  }

  @Test
  @TestMetadata("NamedClassObject.kt")
  public void testNamedClassObject() {
    run("NamedClassObject.kt");
  }

  @Test
  @TestMetadata("namedCompanionObject.kt")
  public void testNamedCompanionObject() {
    run("namedCompanionObject.kt");
  }

  @Test
  @TestMetadata("namelessObjectAsEnumMember.kt")
  public void testNamelessObjectAsEnumMember() {
    run("namelessObjectAsEnumMember.kt");
  }

  @Test
  @TestMetadata("nestedClasses.kt")
  public void testNestedClasses() {
    run("nestedClasses.kt");
  }

  @Test
  @TestMetadata("NestedComments.kt")
  public void testNestedComments() {
    run("NestedComments.kt");
  }

  @Test
  @TestMetadata("NewLinesValidOperations.kt")
  public void testNewLinesValidOperations() {
    run("NewLinesValidOperations.kt");
  }

  @Test
  @TestMetadata("NewlinesInParentheses.kt")
  public void testNewlinesInParentheses() {
    run("NewlinesInParentheses.kt");
  }

  @Test
  @TestMetadata("noCommaBetweenArguments.kt")
  public void testNoCommaBetweenArguments() {
    run("noCommaBetweenArguments.kt");
  }

  @Test
  @TestMetadata("NonTypeBeforeDotInBaseClass.kt")
  public void testNonTypeBeforeDotInBaseClass() {
    run("NonTypeBeforeDotInBaseClass.kt");
  }

  @Test
  @TestMetadata("NotIsAndNotIn.kt")
  public void testNotIsAndNotIn() {
    run("NotIsAndNotIn.kt");
  }

  @Test
  @TestMetadata("ObjectLiteralAsStatement.kt")
  public void testObjectLiteralAsStatement() {
    run("ObjectLiteralAsStatement.kt");
  }

  @Test
  @TestMetadata("objects.kt")
  public void testObjects() {
    run("objects.kt");
  }

  @Test
  @TestMetadata("ParameterNameMising.kt")
  public void testParameterNameMising() {
    run("ParameterNameMising.kt");
  }

  @Test
  @TestMetadata("ParameterType.kt")
  public void testParameterType() {
    run("ParameterType.kt");
  }

  @Test
  @TestMetadata("ParameterType_ERR.kt")
  public void testParameterType_ERR() {
    run("ParameterType_ERR.kt");
  }

  @Test
  @TestMetadata("parameterizedSuspendFunctionType.kt")
  public void testParameterizedSuspendFunctionType() {
    run("parameterizedSuspendFunctionType.kt");
  }

  @Test
  @TestMetadata("parameterizedSuspendFunctionTypeComplex.kt")
  public void testParameterizedSuspendFunctionTypeComplex() {
    run("parameterizedSuspendFunctionTypeComplex.kt");
  }

  @Test
  @TestMetadata("Precedence.kt")
  public void testPrecedence() {
    run("Precedence.kt");
  }

  @Test
  @TestMetadata("PrimaryConstructorModifiers_ERR.kt")
  public void testPrimaryConstructorModifiers_ERR() {
    run("PrimaryConstructorModifiers_ERR.kt");
  }

  @Test
  @TestMetadata("privateConstField.kt")
  public void testPrivateConstField() {
    run("privateConstField.kt");
  }

  @Test
  @TestMetadata("privateToThis.kt")
  public void testPrivateToThis() {
    run("privateToThis.kt");
  }

  @Test
  @TestMetadata("Properties.kt")
  public void testProperties() {
    run("Properties.kt");
  }

  @Test
  @TestMetadata("PropertiesFollowedByInitializers.kt")
  public void testPropertiesFollowedByInitializers() {
    run("PropertiesFollowedByInitializers.kt");
  }

  @Test
  @TestMetadata("Properties_ERR.kt")
  public void testProperties_ERR() {
    run("Properties_ERR.kt");
  }

  @Test
  @TestMetadata("propertyAccessors.kt")
  public void testPropertyAccessors() {
    run("propertyAccessors.kt");
  }

  @Test
  @TestMetadata("PropertyInvokes.kt")
  public void testPropertyInvokes() {
    run("PropertyInvokes.kt");
  }

  @Test
  @TestMetadata("propertyWithConstraints.kt")
  public void testPropertyWithConstraints() {
    run("propertyWithConstraints.kt");
  }

  @Test
  @TestMetadata("QuotedIdentifiers.kt")
  public void testQuotedIdentifiers() {
    run("QuotedIdentifiers.kt");
  }

  @Test
  @TestMetadata("repeatableAnnotation.kt")
  public void testRepeatableAnnotation() {
    run("repeatableAnnotation.kt");
  }

  @Test
  @TestMetadata("repeatableAnnotationClass.kt")
  public void testRepeatableAnnotationClass() {
    run("repeatableAnnotationClass.kt");
  }

  @Test
  @TestMetadata("Reserved.kt")
  public void testReserved() {
    run("Reserved.kt");
  }

  @Test
  @TestMetadata("sealed.kt")
  public void testSealed() {
    run("sealed.kt");
  }

  @Test
  @TestMetadata("sealedInterface.kt")
  public void testSealedInterface() {
    run("sealedInterface.kt");
  }

  @Test
  @TestMetadata("SemicolonAfterIf.kt")
  public void testSemicolonAfterIf() {
    run("SemicolonAfterIf.kt");
  }

  @Test
  @TestMetadata("semicolonBetweenDeclarations.kt")
  public void testSemicolonBetweenDeclarations() {
    run("semicolonBetweenDeclarations.kt");
  }

  @Test
  @TestMetadata("SimpleClassMembers.kt")
  public void testSimpleClassMembers() {
    run("SimpleClassMembers.kt");
  }

  @Test
  @TestMetadata("SimpleClassMembers_ERR.kt")
  public void testSimpleClassMembers_ERR() {
    run("SimpleClassMembers_ERR.kt");
  }

  @Test
  @TestMetadata("SimpleExpressions.kt")
  public void testSimpleExpressions() {
    run("SimpleExpressions.kt");
  }

  @Test
  @TestMetadata("SimpleIntersections.kt")
  public void testSimpleIntersections() {
    run("SimpleIntersections.kt");
  }

  @Test
  @TestMetadata("SimpleModifiers.kt")
  public void testSimpleModifiers() {
    run("SimpleModifiers.kt");
  }

  @Test
  @TestMetadata("SoftKeywords.kt")
  public void testSoftKeywords() {
    run("SoftKeywords.kt");
  }

  @Test
  @TestMetadata("SoftKeywordsInTypeArguments.kt")
  public void testSoftKeywordsInTypeArguments() {
    run("SoftKeywordsInTypeArguments.kt");
  }

  @Test
  @TestMetadata("specialNames.kt")
  public void testSpecialNames() {
    run("specialNames.kt");
  }

  @Test
  @TestMetadata("StringTemplates.kt")
  public void testStringTemplates() {
    run("StringTemplates.kt");
  }

  @Test
  @TestMetadata("suggestGuardSyntax.kt")
  public void testSuggestGuardSyntax() {
    run("suggestGuardSyntax.kt");
  }

  @Test
  @TestMetadata("Super.kt")
  public void testSuper() {
    run("Super.kt");
  }

  @Test
  @TestMetadata("suspendLambda.kt")
  public void testSuspendLambda() {
    run("suspendLambda.kt");
  }

  @Test
  @TestMetadata("topJvmPackageName.kt")
  public void testTopJvmPackageName() {
    run("topJvmPackageName.kt");
  }

  @Test
  @TestMetadata("topJvmPackageNameMultifile.kt")
  public void testTopJvmPackageNameMultifile() {
    run("topJvmPackageNameMultifile.kt");
  }

  @Test
  @TestMetadata("topLevelMembers.kt")
  public void testTopLevelMembers() {
    run("topLevelMembers.kt");
  }

  @Test
  @TestMetadata("topLevelMembersAnnotated.kt")
  public void testTopLevelMembersAnnotated() {
    run("topLevelMembersAnnotated.kt");
  }

  @Test
  @TestMetadata("trailingCommaAllowed.kt")
  public void testTrailingCommaAllowed() {
    run("trailingCommaAllowed.kt");
  }

  @Test
  @TestMetadata("trailingCommaForbidden.kt")
  public void testTrailingCommaForbidden() {
    run("trailingCommaForbidden.kt");
  }

  @Test
  @TestMetadata("TraitConstructor.kt")
  public void testTraitConstructor() {
    run("TraitConstructor.kt");
  }

  @Test
  @TestMetadata("TripleDot.kt")
  public void testTripleDot() {
    run("TripleDot.kt");
  }

  @Test
  @TestMetadata("TryRecovery.kt")
  public void testTryRecovery() {
    run("TryRecovery.kt");
  }

  @Test
  @TestMetadata("TypeAlias.kt")
  public void testTypeAlias() {
    run("TypeAlias.kt");
  }

  @Test
  @TestMetadata("typeAliasExpansion.kt")
  public void testTypeAliasExpansion() {
    run("typeAliasExpansion.kt");
  }

  @Test
  @TestMetadata("typeAliasWithConstraints.kt")
  public void testTypeAliasWithConstraints() {
    run("typeAliasWithConstraints.kt");
  }

  @Test
  @TestMetadata("TypeAlias_ERR.kt")
  public void testTypeAlias_ERR() {
    run("TypeAlias_ERR.kt");
  }

  @Test
  @TestMetadata("typeAliases.kt")
  public void testTypeAliases() {
    run("typeAliases.kt");
  }

  @Test
  @TestMetadata("typeBoundsAndDelegationSpecifiers.kt")
  public void testTypeBoundsAndDelegationSpecifiers() {
    run("typeBoundsAndDelegationSpecifiers.kt");
  }

  @Test
  @TestMetadata("TypeConstraints.kt")
  public void testTypeConstraints() {
    run("TypeConstraints.kt");
  }

  @Test
  @TestMetadata("TypeExpressionAmbiguities_ERR.kt")
  public void testTypeExpressionAmbiguities_ERR() {
    run("TypeExpressionAmbiguities_ERR.kt");
  }

  @Test
  @TestMetadata("TypeModifiers.kt")
  public void testTypeModifiers() {
    run("TypeModifiers.kt");
  }

  @Test
  @TestMetadata("typeModifiers2.kt")
  public void testTypeModifiers2() {
    run("typeModifiers2.kt");
  }

  @Test
  @TestMetadata("TypeModifiersParenthesized.kt")
  public void testTypeModifiersParenthesized() {
    run("TypeModifiersParenthesized.kt");
  }

  @Test
  @TestMetadata("TypeModifiers_ERR.kt")
  public void testTypeModifiers_ERR() {
    run("TypeModifiers_ERR.kt");
  }

  @Test
  @TestMetadata("TypeParametersBeforeName.kt")
  public void testTypeParametersBeforeName() {
    run("TypeParametersBeforeName.kt");
  }

  @Test
  @TestMetadata("typeParams.kt")
  public void testTypeParams() {
    run("typeParams.kt");
  }

  @Test
  @TestMetadata("TypealiasIsKeyword.kt")
  public void testTypealiasIsKeyword() {
    run("TypealiasIsKeyword.kt");
  }

  @Test
  @TestMetadata("types.kt")
  public void testTypes() {
    run("types.kt");
  }

  @Test
  @TestMetadata("underscoreParameterName.kt")
  public void testUnderscoreParameterName() {
    run("underscoreParameterName.kt");
  }

  @Test
  @TestMetadata("UnderscoredTypeArgumentsOfCall.kt")
  public void testUnderscoredTypeArgumentsOfCall() {
    run("UnderscoredTypeArgumentsOfCall.kt");
  }

  @Test
  @TestMetadata("UnderscoredTypeArgumentsOfCallIllegal.kt")
  public void testUnderscoredTypeArgumentsOfCallIllegal() {
    run("UnderscoredTypeArgumentsOfCallIllegal.kt");
  }

  @Test
  @TestMetadata("UnderscoredTypeArgumentsOfType.kt")
  public void testUnderscoredTypeArgumentsOfType() {
    run("UnderscoredTypeArgumentsOfType.kt");
  }

  @Test
  @TestMetadata("UnderscoredTypeParameters.kt")
  public void testUnderscoredTypeParameters() {
    run("UnderscoredTypeParameters.kt");
  }

  @Test
  @TestMetadata("UnsignedLiteral.kt")
  public void testUnsignedLiteral() {
    run("UnsignedLiteral.kt");
  }

  @Test
  @TestMetadata("validKotlinFunInterface.kt")
  public void testValidKotlinFunInterface() {
    run("validKotlinFunInterface.kt");
  }

  @Test
  @TestMetadata("valueClass.kt")
  public void testValueClass() {
    run("valueClass.kt");
  }

  @Test
  @TestMetadata("varargArgumentWithFunctionalType.kt")
  public void testVarargArgumentWithFunctionalType() {
    run("varargArgumentWithFunctionalType.kt");
  }

  @Test
  @TestMetadata("When.kt")
  public void testWhen() {
    run("When.kt");
  }

  @Test
  @TestMetadata("WhenWithSubjectVariable.kt")
  public void testWhenWithSubjectVariable() {
    run("WhenWithSubjectVariable.kt");
  }

  @Test
  @TestMetadata("WhenWithSubjectVariable_ERR.kt")
  public void testWhenWithSubjectVariable_ERR() {
    run("WhenWithSubjectVariable_ERR.kt");
  }

  @Test
  @TestMetadata("WhenWithSubjectVariable_SoftModifierName.kt")
  public void testWhenWithSubjectVariable_SoftModifierName() {
    run("WhenWithSubjectVariable_SoftModifierName.kt");
  }

  @Test
  @TestMetadata("When_ERR.kt")
  public void testWhen_ERR() {
    run("When_ERR.kt");
  }

  @Nested
  @TestMetadata("compiler/testData/psi/annotation")
  @TestDataPath("$PROJECT_ROOT")
  public class Annotation {
    private void run(String fileName) {
      runTest("compiler/testData/psi/annotation/" + fileName);
    }

    @Test
    public void testAllFilesPresentInAnnotation() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("annotatedDefaultPropertyAccessor.kt")
    public void testAnnotatedDefaultPropertyAccessor() {
      run("annotatedDefaultPropertyAccessor.kt");
    }

    @Test
    @TestMetadata("AnnotatedExpressions.kt")
    public void testAnnotatedExpressions() {
      run("AnnotatedExpressions.kt");
    }

    @Test
    @TestMetadata("annotatedProperties.kt")
    public void testAnnotatedProperties() {
      run("annotatedProperties.kt");
    }

    @Test
    @TestMetadata("annotatedProperty.kt")
    public void testAnnotatedProperty() {
      run("annotatedProperty.kt");
    }

    @Test
    @TestMetadata("annotatedReturnType.kt")
    public void testAnnotatedReturnType() {
      run("annotatedReturnType.kt");
    }

    @Test
    @TestMetadata("annotatedTypeConstraint.kt")
    public void testAnnotatedTypeConstraint() {
      run("annotatedTypeConstraint.kt");
    }

    @Test
    @TestMetadata("annotatedWhenExpression.kt")
    public void testAnnotatedWhenExpression() {
      run("annotatedWhenExpression.kt");
    }

    @Test
    @TestMetadata("Annotations.kt")
    public void testAnnotations() {
      run("Annotations.kt");
    }

    @Test
    @TestMetadata("annotationsOnNullableTypes.kt")
    public void testAnnotationsOnNullableTypes() {
      run("annotationsOnNullableTypes.kt");
    }

    @Test
    @TestMetadata("annotationsOnParenthesizedTypes.kt")
    public void testAnnotationsOnParenthesizedTypes() {
      run("annotationsOnParenthesizedTypes.kt");
    }

    @Test
    @TestMetadata("AnnotationsOnPatterns.kt")
    public void testAnnotationsOnPatterns() {
      run("AnnotationsOnPatterns.kt");
    }

    @Test
    @TestMetadata("Annotations_ERR.kt")
    public void testAnnotations_ERR() {
      run("Annotations_ERR.kt");
    }

    @Test
    @TestMetadata("forParameters.kt")
    public void testForParameters() {
      run("forParameters.kt");
    }

    @Test
    @TestMetadata("lambda.kt")
    public void testLambda() {
      run("lambda.kt");
    }

    @Test
    @TestMetadata("lambdaRecovery.kt")
    public void testLambdaRecovery() {
      run("lambdaRecovery.kt");
    }

    @Test
    @TestMetadata("multiDeclaration.kt")
    public void testMultiDeclaration() {
      run("multiDeclaration.kt");
    }

    @Test
    @TestMetadata("noParameterYet.kt")
    public void testNoParameterYet() {
      run("noParameterYet.kt");
    }

    @Test
    @TestMetadata("oldAnnotationsRecovery.kt")
    public void testOldAnnotationsRecovery() {
      run("oldAnnotationsRecovery.kt");
    }

    @Test
    @TestMetadata("ShortAnnotations.kt")
    public void testShortAnnotations() {
      run("ShortAnnotations.kt");
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/at")
    @TestDataPath("$PROJECT_ROOT")
    public class At {
      private void run(String fileName) {
        runTest("compiler/testData/psi/annotation/at/" + fileName);
      }

      @Test
      public void testAllFilesPresentInAt() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/at"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("annotationAtFileStart.kt")
      public void testAnnotationAtFileStart() {
        run("annotationAtFileStart.kt");
      }

      @Test
      @TestMetadata("annotationValueArgumentsAmbiguity.kt")
      public void testAnnotationValueArgumentsAmbiguity() {
        run("annotationValueArgumentsAmbiguity.kt");
      }

      @Test
      @TestMetadata("blockLevelExpressions.kt")
      public void testBlockLevelExpressions() {
        run("blockLevelExpressions.kt");
      }

      @Test
      @TestMetadata("blockLevelExpressionsNoNewLine.kt")
      public void testBlockLevelExpressionsNoNewLine() {
        run("blockLevelExpressionsNoNewLine.kt");
      }

      @Test
      @TestMetadata("danglingBlockLevelAnnotations.kt")
      public void testDanglingBlockLevelAnnotations() {
        run("danglingBlockLevelAnnotations.kt");
      }

      @Test
      @TestMetadata("declarationsJustAtTyped.kt")
      public void testDeclarationsJustAtTyped() {
        run("declarationsJustAtTyped.kt");
      }

      @Test
      @TestMetadata("enumEntries.kt")
      public void testEnumEntries() {
        run("enumEntries.kt");
      }

      @Test
      @TestMetadata("expressionJustAtTyped.kt")
      public void testExpressionJustAtTyped() {
        run("expressionJustAtTyped.kt");
      }

      @Test
      @TestMetadata("kt21055.kt")
      public void testKt21055() {
        run("kt21055.kt");
      }

      @Test
      @TestMetadata("modifierAtFileStart.kt")
      public void testModifierAtFileStart() {
        run("modifierAtFileStart.kt");
      }

      @Test
      @TestMetadata("primaryConstructor.kt")
      public void testPrimaryConstructor() {
        run("primaryConstructor.kt");
      }

      @Test
      @TestMetadata("recoveryWhitespaceBeforeColon.kt")
      public void testRecoveryWhitespaceBeforeColon() {
        run("recoveryWhitespaceBeforeColon.kt");
      }

      @Test
      @TestMetadata("recoveryWhitespaceBeforeColon_ERR.kt")
      public void testRecoveryWhitespaceBeforeColon_ERR() {
        run("recoveryWhitespaceBeforeColon_ERR.kt");
      }

      @Test
      @TestMetadata("validDeclarations.kt")
      public void testValidDeclarations() {
        run("validDeclarations.kt");
      }

      @Test
      @TestMetadata("validExpressions.kt")
      public void testValidExpressions() {
        run("validExpressions.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/functionalTypes")
    @TestDataPath("$PROJECT_ROOT")
    public class FunctionalTypes {
      private void run(String fileName) {
        runTest("compiler/testData/psi/annotation/functionalTypes/" + fileName);
      }

      @Test
      public void testAllFilesPresentInFunctionalTypes() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax")
      @TestDataPath("$PROJECT_ROOT")
      public class RegressionForSimilarSyntax {
        private void run(String fileName) {
          runTest("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax/" + fileName);
        }

        @Test
        public void testAllFilesPresentInRegressionForSimilarSyntax() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("forDestructuring.kt")
        public void testForDestructuring() {
          run("forDestructuring.kt");
        }

        @Test
        @TestMetadata("lambdaParameterDeclaration.kt")
        public void testLambdaParameterDeclaration() {
          run("lambdaParameterDeclaration.kt");
        }

        @Test
        @TestMetadata("variableDestructuring.kt")
        public void testVariableDestructuring() {
          run("variableDestructuring.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/functionalTypes/withParentheses")
      @TestDataPath("$PROJECT_ROOT")
      public class WithParentheses {
        private void run(String fileName) {
          runTest("compiler/testData/psi/annotation/functionalTypes/withParentheses/" + fileName);
        }

        @Test
        public void testAllFilesPresentInWithParentheses() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes/withParentheses"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("withParameter.kt")
        public void testWithParameter() {
          run("withParameter.kt");
        }

        @Test
        @TestMetadata("withoutParameter.kt")
        public void testWithoutParameter() {
          run("withoutParameter.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/functionalTypes/withoutParentheses")
      @TestDataPath("$PROJECT_ROOT")
      public class WithoutParentheses {
        private void run(String fileName) {
          runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/" + fileName);
        }

        @Test
        public void testAllFilesPresentInWithoutParentheses() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes/withoutParentheses"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("annotationList.kt")
        public void testAnnotationList() {
          run("annotationList.kt");
        }

        @Test
        @TestMetadata("withParameter.kt")
        public void testWithParameter() {
          run("withParameter.kt");
        }

        @Test
        @TestMetadata("withReveiver.kt")
        public void testWithReveiver() {
          run("withReveiver.kt");
        }

        @Test
        @TestMetadata("withoutParameter.kt")
        public void testWithoutParameter() {
          run("withoutParameter.kt");
        }

        @Test
        @TestMetadata("withoutParameterOnSuspend.kt")
        public void testWithoutParameterOnSuspend() {
          run("withoutParameterOnSuspend.kt");
        }
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/list")
    @TestDataPath("$PROJECT_ROOT")
    public class List {
      private void run(String fileName) {
        runTest("compiler/testData/psi/annotation/list/" + fileName);
      }

      @Test
      public void testAllFilesPresentInList() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/list"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("basic.kt")
      public void testBasic() {
        run("basic.kt");
      }

      @Test
      @TestMetadata("recovery.kt")
      public void testRecovery() {
        run("recovery.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/modifiersMigration")
    @TestDataPath("$PROJECT_ROOT")
    public class ModifiersMigration {
      private void run(String fileName) {
        runTest("compiler/testData/psi/annotation/modifiersMigration/" + fileName);
      }

      @Test
      public void testAllFilesPresentInModifiersMigration() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/modifiersMigration"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("newModifiers.kt")
      public void testNewModifiers() {
        run("newModifiers.kt");
      }

      @Test
      @TestMetadata("oldUsages.kt")
      public void testOldUsages() {
        run("oldUsages.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/options")
    @TestDataPath("$PROJECT_ROOT")
    public class Options {
      private void run(String fileName) {
        runTest("compiler/testData/psi/annotation/options/" + fileName);
      }

      @Test
      public void testAllFilesPresentInOptions() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/options"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("annotationAsArg.kt")
      public void testAnnotationAsArg() {
        run("annotationAsArg.kt");
      }

      @Test
      @TestMetadata("annotationAsArgComplex.kt")
      public void testAnnotationAsArgComplex() {
        run("annotationAsArgComplex.kt");
      }

      @Test
      @TestMetadata("java.kt")
      public void testJava() {
        run("java.kt");
      }

      @Test
      @TestMetadata("local.kt")
      public void testLocal() {
        run("local.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/targeted")
    @TestDataPath("$PROJECT_ROOT")
    public class Targeted {
      private void run(String fileName) {
        runTest("compiler/testData/psi/annotation/targeted/" + fileName);
      }

      @Test
      public void testAllFilesPresentInTargeted() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("onAll.kt")
      public void testOnAll() {
        run("onAll.kt");
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/targeted/onField")
      @TestDataPath("$PROJECT_ROOT")
      public class OnField {
        private void run(String fileName) {
          runTest("compiler/testData/psi/annotation/targeted/onField/" + fileName);
        }

        @Test
        public void testAllFilesPresentInOnField() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onField"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("delegate.kt")
        public void testDelegate() {
          run("delegate.kt");
        }

        @Test
        @TestMetadata("fqName.kt")
        public void testFqName() {
          run("fqName.kt");
        }

        @Test
        @TestMetadata("inWrongPlace.kt")
        public void testInWrongPlace() {
          run("inWrongPlace.kt");
        }

        @Test
        @TestMetadata("manyInOneAnnotationBlock.kt")
        public void testManyInOneAnnotationBlock() {
          run("manyInOneAnnotationBlock.kt");
        }

        @Test
        @TestMetadata("simpleFieldAnnotation.kt")
        public void testSimpleFieldAnnotation() {
          run("simpleFieldAnnotation.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/targeted/onFile")
      @TestDataPath("$PROJECT_ROOT")
      public class OnFile {
        private void run(String fileName) {
          runTest("compiler/testData/psi/annotation/targeted/onFile/" + fileName);
        }

        @Test
        public void testAllFilesPresentInOnFile() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onFile"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("fileAnnotationInWrongPlace.kt")
        public void testFileAnnotationInWrongPlace() {
          run("fileAnnotationInWrongPlace.kt");
        }

        @Test
        @TestMetadata("manyAnnotationBlocks.kt")
        public void testManyAnnotationBlocks() {
          run("manyAnnotationBlocks.kt");
        }

        @Test
        @TestMetadata("manyInOneAnnotationBlock.kt")
        public void testManyInOneAnnotationBlock() {
          run("manyInOneAnnotationBlock.kt");
        }

        @Test
        @TestMetadata("nonFIleAnnotationBeforePackage.kt")
        public void testNonFIleAnnotationBeforePackage() {
          run("nonFIleAnnotationBeforePackage.kt");
        }

        @Test
        @TestMetadata("single.kt")
        public void testSingle() {
          run("single.kt");
        }

        @Test
        @TestMetadata("withoutFileAnnotationAndPackageDeclaration.kt")
        public void testWithoutFileAnnotationAndPackageDeclaration() {
          run("withoutFileAnnotationAndPackageDeclaration.kt");
        }

        @Test
        @TestMetadata("withoutPackage.kt")
        public void testWithoutPackage() {
          run("withoutPackage.kt");
        }

        @Test
        @TestMetadata("withoutPackageWithSimpleAnnotation.kt")
        public void testWithoutPackageWithSimpleAnnotation() {
          run("withoutPackageWithSimpleAnnotation.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/targeted/onGetSetSparam")
      @TestDataPath("$PROJECT_ROOT")
      public class OnGetSetSparam {
        private void run(String fileName) {
          runTest("compiler/testData/psi/annotation/targeted/onGetSetSparam/" + fileName);
        }

        @Test
        public void testAllFilesPresentInOnGetSetSparam() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onGetSetSparam"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("inWrongPlace.kt")
        public void testInWrongPlace() {
          run("inWrongPlace.kt");
        }

        @Test
        @TestMetadata("simple.kt")
        public void testSimple() {
          run("simple.kt");
        }

        @Test
        @TestMetadata("twoAnnotationLists.kt")
        public void testTwoAnnotationLists() {
          run("twoAnnotationLists.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/targeted/onParam")
      @TestDataPath("$PROJECT_ROOT")
      public class OnParam {
        private void run(String fileName) {
          runTest("compiler/testData/psi/annotation/targeted/onParam/" + fileName);
        }

        @Test
        public void testAllFilesPresentInOnParam() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onParam"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("modifiers.kt")
        public void testModifiers() {
          run("modifiers.kt");
        }

        @Test
        @TestMetadata("recovery.kt")
        public void testRecovery() {
          run("recovery.kt");
        }

        @Test
        @TestMetadata("simple.kt")
        public void testSimple() {
          run("simple.kt");
        }

        @Test
        @TestMetadata("targetExpected.kt")
        public void testTargetExpected() {
          run("targetExpected.kt");
        }
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/values")
    @TestDataPath("$PROJECT_ROOT")
    public class Values {
      private void run(String fileName) {
        runTest("compiler/testData/psi/annotation/values/" + fileName);
      }

      @Test
      public void testAllFilesPresentInValues() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/values"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("arrays.kt")
      public void testArrays() {
        run("arrays.kt");
      }

      @Test
      @TestMetadata("arraysWithNonConstantValue.kt")
      public void testArraysWithNonConstantValue() {
        run("arraysWithNonConstantValue.kt");
      }

      @Test
      @TestMetadata("classLiterals.kt")
      public void testClassLiterals() {
        run("classLiterals.kt");
      }

      @Test
      @TestMetadata("deprecated.kt")
      public void testDeprecated() {
        run("deprecated.kt");
      }

      @Test
      @TestMetadata("enumArray.kt")
      public void testEnumArray() {
        run("enumArray.kt");
      }

      @Test
      @TestMetadata("enumLiterals.kt")
      public void testEnumLiterals() {
        run("enumLiterals.kt");
      }

      @Test
      @TestMetadata("intVarargLiterals.kt")
      public void testIntVarargLiterals() {
        run("intVarargLiterals.kt");
      }

      @Test
      @TestMetadata("longStringTemplateEntryWithTwoExpressions.kt")
      public void testLongStringTemplateEntryWithTwoExpressions() {
        run("longStringTemplateEntryWithTwoExpressions.kt");
      }

      @Test
      @TestMetadata("nestedAnnotation.kt")
      public void testNestedAnnotation() {
        run("nestedAnnotation.kt");
      }

      @Test
      @TestMetadata("qualifiedLiterals.kt")
      public void testQualifiedLiterals() {
        run("qualifiedLiterals.kt");
      }

      @Test
      @TestMetadata("simpleLiterals.kt")
      public void testSimpleLiterals() {
        run("simpleLiterals.kt");
      }

      @Test
      @TestMetadata("stringLiterals.kt")
      public void testStringLiterals() {
        run("stringLiterals.kt");
      }
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/contextParameters")
  @TestDataPath("$PROJECT_ROOT")
  public class ContextParameters {
    private void run(String fileName) {
      runTest("compiler/testData/psi/contextParameters/" + fileName);
    }

    @Test
    public void testAllFilesPresentInContextParameters() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contextParameters"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("annotatedContextParameterType.kt")
    public void testAnnotatedContextParameterType() {
      run("annotatedContextParameterType.kt");
    }

    @Test
    @TestMetadata("anonymousFunction.kt")
    public void testAnonymousFunction() {
      run("anonymousFunction.kt");
    }

    @Test
    @TestMetadata("contextParametersOnCallableMembers.kt")
    public void testContextParametersOnCallableMembers() {
      run("contextParametersOnCallableMembers.kt");
    }

    @Test
    @TestMetadata("contextParametersOnTopLevelCallables.kt")
    public void testContextParametersOnTopLevelCallables() {
      run("contextParametersOnTopLevelCallables.kt");
    }

    @Test
    @TestMetadata("contextReceiversCallableMembers.kt")
    public void testContextReceiversCallableMembers() {
      run("contextReceiversCallableMembers.kt");
    }

    @Test
    @TestMetadata("contextReceiversOnClass.kt")
    public void testContextReceiversOnClass() {
      run("contextReceiversOnClass.kt");
    }

    @Test
    @TestMetadata("contextReceiversOnFunctionType.kt")
    public void testContextReceiversOnFunctionType() {
      run("contextReceiversOnFunctionType.kt");
    }

    @Test
    @TestMetadata("contextReceiversOnTopLevelCallables.kt")
    public void testContextReceiversOnTopLevelCallables() {
      run("contextReceiversOnTopLevelCallables.kt");
    }

    @Test
    @TestMetadata("danglingContextParameter.kt")
    public void testDanglingContextParameter() {
      run("danglingContextParameter.kt");
    }

    @Test
    @TestMetadata("danglingContextParameterAndAnnotations.kt")
    public void testDanglingContextParameterAndAnnotations() {
      run("danglingContextParameterAndAnnotations.kt");
    }

    @Test
    @TestMetadata("differentTypes.kt")
    public void testDifferentTypes() {
      run("differentTypes.kt");
    }

    @Test
    @TestMetadata("functions.kt")
    public void testFunctions() {
      run("functions.kt");
    }

    @Test
    @TestMetadata("labelInFunctionTypeContext.kt")
    public void testLabelInFunctionTypeContext() {
      run("labelInFunctionTypeContext.kt");
    }

    @Test
    @TestMetadata("parsingWithLocalDeclarations.kt")
    public void testParsingWithLocalDeclarations() {
      run("parsingWithLocalDeclarations.kt");
    }

    @Test
    @TestMetadata("parsingWithLocalDeclarationsIncorrect.kt")
    public void testParsingWithLocalDeclarationsIncorrect() {
      run("parsingWithLocalDeclarationsIncorrect.kt");
    }

    @Test
    @TestMetadata("properties.kt")
    public void testProperties() {
      run("properties.kt");
    }

    @Test
    @TestMetadata("syntaxError.kt")
    public void testSyntaxError() {
      run("syntaxError.kt");
    }

    @Test
    @TestMetadata("trailingComma.kt")
    public void testTrailingComma() {
      run("trailingComma.kt");
    }

    @Test
    @TestMetadata("trailingCommaForbidden.kt")
    public void testTrailingCommaForbidden() {
      run("trailingCommaForbidden.kt");
    }

    @Test
    @TestMetadata("unnamed.kt")
    public void testUnnamed() {
      run("unnamed.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/contracts")
  @TestDataPath("$PROJECT_ROOT")
  public class Contracts {
    private void run(String fileName) {
      runTest("compiler/testData/psi/contracts/" + fileName);
    }

    @Test
    public void testAllFilesPresentInContracts() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("annotatedContract.kt")
    public void testAnnotatedContract() {
      run("annotatedContract.kt");
    }

    @Test
    @TestMetadata("contracts.kt")
    public void testContracts() {
      run("contracts.kt");
    }

    @Test
    @TestMetadata("contractsPropertyAccessors.kt")
    public void testContractsPropertyAccessors() {
      run("contractsPropertyAccessors.kt");
    }

    @Test
    @TestMetadata("contractsSecondaryConstructor.kt")
    public void testContractsSecondaryConstructor() {
      run("contractsSecondaryConstructor.kt");
    }

    @Test
    @TestMetadata("FunctionWithMultilineContract.kt")
    public void testFunctionWithMultilineContract() {
      run("FunctionWithMultilineContract.kt");
    }

    @Test
    @TestMetadata("FunctionsWithTypeConstraintsAndContract.kt")
    public void testFunctionsWithTypeConstraintsAndContract() {
      run("FunctionsWithTypeConstraintsAndContract.kt");
    }

    @Test
    @TestMetadata("nonKotlinContractCall.kt")
    public void testNonKotlinContractCall() {
      run("nonKotlinContractCall.kt");
    }

    @Test
    @TestMetadata("nonKotlinContractCall2.kt")
    public void testNonKotlinContractCall2() {
      run("nonKotlinContractCall2.kt");
    }

    @Test
    @TestMetadata("operator.kt")
    public void testOperator() {
      run("operator.kt");
    }

    @Test
    @TestMetadata("PropertyAccessorsContracts.kt")
    public void testPropertyAccessorsContracts() {
      run("PropertyAccessorsContracts.kt");
    }

    @Test
    @TestMetadata("SimpleFunctionWithContract.kt")
    public void testSimpleFunctionWithContract() {
      run("SimpleFunctionWithContract.kt");
    }

    @Test
    @TestMetadata("withContextParameters.kt")
    public void testWithContextParameters() {
      run("withContextParameters.kt");
    }

    @Nested
    @TestMetadata("compiler/testData/psi/contracts/good")
    @TestDataPath("$PROJECT_ROOT")
    public class Good {
      private void run(String fileName) {
        runTest("compiler/testData/psi/contracts/good/" + fileName);
      }

      @Test
      @TestMetadata("accessorsAllowed.kt")
      public void testAccessorsAllowed() {
        run("accessorsAllowed.kt");
      }

      @Test
      public void testAllFilesPresentInGood() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Nested
      @TestMetadata("compiler/testData/psi/contracts/good/callsInPlace")
      @TestDataPath("$PROJECT_ROOT")
      public class CallsInPlace {
        private void run(String fileName) {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/" + fileName);
        }

        @Test
        public void testAllFilesPresentInCallsInPlace() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good/callsInPlace"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("atLeastOnce.kt")
        public void testAtLeastOnce() {
          run("atLeastOnce.kt");
        }

        @Test
        @TestMetadata("atMostOnce.kt")
        public void testAtMostOnce() {
          run("atMostOnce.kt");
        }

        @Test
        @TestMetadata("contractsUsage.kt")
        public void testContractsUsage() {
          run("contractsUsage.kt");
        }

        @Test
        @TestMetadata("exactlyOnce.kt")
        public void testExactlyOnce() {
          run("exactlyOnce.kt");
        }

        @Test
        @TestMetadata("flow.kt")
        public void testFlow() {
          run("flow.kt");
        }

        @Test
        @TestMetadata("inPlaceLambda.kt")
        public void testInPlaceLambda() {
          run("inPlaceLambda.kt");
        }

        @Test
        @TestMetadata("infiniteLoop.kt")
        public void testInfiniteLoop() {
          run("infiniteLoop.kt");
        }

        @Test
        @TestMetadata("namedArgument.kt")
        public void testNamedArgument() {
          run("namedArgument.kt");
        }

        @Test
        @TestMetadata("simple.kt")
        public void testSimple() {
          run("simple.kt");
        }

        @Test
        @TestMetadata("tryFinally.kt")
        public void testTryFinally() {
          run("tryFinally.kt");
        }

        @Test
        @TestMetadata("unknown.kt")
        public void testUnknown() {
          run("unknown.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/contracts/good/holdsIn")
      @TestDataPath("$PROJECT_ROOT")
      public class HoldsIn {
        private void run(String fileName) {
          runTest("compiler/testData/psi/contracts/good/holdsIn/" + fileName);
        }

        @Test
        public void testAllFilesPresentInHoldsIn() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good/holdsIn"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("combinedContractWithCallInPlace.kt")
        public void testCombinedContractWithCallInPlace() {
          run("combinedContractWithCallInPlace.kt");
        }

        @Test
        @TestMetadata("combinedContractWithImpliesReturn.kt")
        public void testCombinedContractWithImpliesReturn() {
          run("combinedContractWithImpliesReturn.kt");
        }

        @Test
        @TestMetadata("combinedContractWithReturnImplies.kt")
        public void testCombinedContractWithReturnImplies() {
          run("combinedContractWithReturnImplies.kt");
        }

        @Test
        @TestMetadata("conditionWithDefaultValue.kt")
        public void testConditionWithDefaultValue() {
          run("conditionWithDefaultValue.kt");
        }

        @Test
        @TestMetadata("differentConditions.kt")
        public void testDifferentConditions() {
          run("differentConditions.kt");
        }

        @Test
        @TestMetadata("holdsInBaseCases.kt")
        public void testHoldsInBaseCases() {
          run("holdsInBaseCases.kt");
        }

        @Test
        @TestMetadata("withContextParameters.kt")
        public void testWithContextParameters() {
          run("withContextParameters.kt");
        }

        @Test
        @TestMetadata("withErasedType.kt")
        public void testWithErasedType() {
          run("withErasedType.kt");
        }

        @Test
        @TestMetadata("withExtensionReceiver.kt")
        public void testWithExtensionReceiver() {
          run("withExtensionReceiver.kt");
        }

        @Test
        @TestMetadata("withInfixFunction.kt")
        public void testWithInfixFunction() {
          run("withInfixFunction.kt");
        }

        @Test
        @TestMetadata("withOperatorFunction.kt")
        public void testWithOperatorFunction() {
          run("withOperatorFunction.kt");
        }

        @Test
        @TestMetadata("withReturnsImplies.kt")
        public void testWithReturnsImplies() {
          run("withReturnsImplies.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/contracts/good/returnsImplies")
      @TestDataPath("$PROJECT_ROOT")
      public class ReturnsImplies {
        private void run(String fileName) {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/" + fileName);
        }

        @Test
        public void testAllFilesPresentInReturnsImplies() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good/returnsImplies"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("baseConditions.kt")
        public void testBaseConditions() {
          run("baseConditions.kt");
        }

        @Test
        @TestMetadata("booleanOperators.kt")
        public void testBooleanOperators() {
          run("booleanOperators.kt");
        }

        @Test
        @TestMetadata("conditionLogic.kt")
        public void testConditionLogic() {
          run("conditionLogic.kt");
        }

        @Test
        @TestMetadata("eqNotEq.kt")
        public void testEqNotEq() {
          run("eqNotEq.kt");
        }

        @Test
        @TestMetadata("impliesReturnsInArgumentPosition.kt")
        public void testImpliesReturnsInArgumentPosition() {
          run("impliesReturnsInArgumentPosition.kt");
        }

        @Test
        @TestMetadata("impliesReturnsWithIncrement.kt")
        public void testImpliesReturnsWithIncrement() {
          run("impliesReturnsWithIncrement.kt");
        }

        @Test
        @TestMetadata("inapplicable.kt")
        public void testInapplicable() {
          run("inapplicable.kt");
        }

        @Test
        @TestMetadata("namedArguments.kt")
        public void testNamedArguments() {
          run("namedArguments.kt");
        }

        @Test
        @TestMetadata("nestedCallOfImpliesReturnsContract.kt")
        public void testNestedCallOfImpliesReturnsContract() {
          run("nestedCallOfImpliesReturnsContract.kt");
        }

        @Test
        @TestMetadata("notNull.kt")
        public void testNotNull() {
          run("notNull.kt");
        }

        @Test
        @TestMetadata("propertyAccessors.kt")
        public void testPropertyAccessors() {
          run("propertyAccessors.kt");
        }

        @Test
        @TestMetadata("receivers.kt")
        public void testReceivers() {
          run("receivers.kt");
        }

        @Test
        @TestMetadata("safeCall.kt")
        public void testSafeCall() {
          run("safeCall.kt");
        }

        @Test
        @TestMetadata("trickyCases.kt")
        public void testTrickyCases() {
          run("trickyCases.kt");
        }

        @Test
        @TestMetadata("typePredicate.kt")
        public void testTypePredicate() {
          run("typePredicate.kt");
        }

        @Test
        @TestMetadata("withDataFlowBasedExhaustivenes.kt")
        public void testWithDataFlowBasedExhaustivenes() {
          run("withDataFlowBasedExhaustivenes.kt");
        }

        @Test
        @TestMetadata("withDestructuringDeclaration.kt")
        public void testWithDestructuringDeclaration() {
          run("withDestructuringDeclaration.kt");
        }

        @Test
        @TestMetadata("withErasedType.kt")
        public void testWithErasedType() {
          run("withErasedType.kt");
        }

        @Test
        @TestMetadata("withInfixFunction.kt")
        public void testWithInfixFunction() {
          run("withInfixFunction.kt");
        }

        @Test
        @TestMetadata("withOperatorFunction.kt")
        public void testWithOperatorFunction() {
          run("withOperatorFunction.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/contracts/good/variousContracts")
      @TestDataPath("$PROJECT_ROOT")
      public class VariousContracts {
        private void run(String fileName) {
          runTest("compiler/testData/psi/contracts/good/variousContracts/" + fileName);
        }

        @Test
        public void testAllFilesPresentInVariousContracts() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good/variousContracts"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Nested
        @TestMetadata("compiler/testData/psi/contracts/good/variousContracts/newSyntax")
        @TestDataPath("$PROJECT_ROOT")
        public class NewSyntax {
          private void run(String fileName) {
            runTest("compiler/testData/psi/contracts/good/variousContracts/newSyntax/" + fileName);
          }

          @Test
          public void testAllFilesPresentInNewSyntax() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good/variousContracts/newSyntax"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
          }

          @Test
          @TestMetadata("functionsWithContract.kt")
          public void testFunctionsWithContract() {
            run("functionsWithContract.kt");
          }
        }
      }
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/destructuring")
  @TestDataPath("$PROJECT_ROOT")
  public class Destructuring {
    private void run(String fileName) {
      runTest("compiler/testData/psi/destructuring/" + fileName);
    }

    @Test
    public void testAllFilesPresentInDestructuring() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/destructuring"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("annotationOnFullNameBasedDestructuring.kt")
    public void testAnnotationOnFullNameBasedDestructuring() {
      run("annotationOnFullNameBasedDestructuring.kt");
    }

    @Test
    @TestMetadata("danglingAnnotation.kt")
    public void testDanglingAnnotation() {
      run("danglingAnnotation.kt");
    }

    @Test
    @TestMetadata("freezeKt79951.kt")
    public void testFreezeKt79951() {
      run("freezeKt79951.kt");
    }

    @Test
    @TestMetadata("fullNameBasedDestructuring.kt")
    public void testFullNameBasedDestructuring() {
      run("fullNameBasedDestructuring.kt");
    }

    @Test
    @TestMetadata("fullNameBasedDestructuringErrors.kt")
    public void testFullNameBasedDestructuringErrors() {
      run("fullNameBasedDestructuringErrors.kt");
    }

    @Test
    @TestMetadata("fullPositionBasedDestructuring.kt")
    public void testFullPositionBasedDestructuring() {
      run("fullPositionBasedDestructuring.kt");
    }

    @Test
    @TestMetadata("fullPositionBasedDestructuringErrors.kt")
    public void testFullPositionBasedDestructuringErrors() {
      run("fullPositionBasedDestructuringErrors.kt");
    }

    @Test
    @TestMetadata("ktij23263.kt")
    public void testKtij23263() {
      run("ktij23263.kt");
    }

    @Test
    @TestMetadata("shortNameBasedDestructuringWithRenaming.kt")
    public void testShortNameBasedDestructuringWithRenaming() {
      run("shortNameBasedDestructuringWithRenaming.kt");
    }

    @Test
    @TestMetadata("shortPositionBasedDestructuring.kt")
    public void testShortPositionBasedDestructuring() {
      run("shortPositionBasedDestructuring.kt");
    }

    @Test
    @TestMetadata("shortPositionBasedDestructuringErrors.kt")
    public void testShortPositionBasedDestructuringErrors() {
      run("shortPositionBasedDestructuringErrors.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/examples")
  @TestDataPath("$PROJECT_ROOT")
  public class Examples {
    private void run(String fileName) {
      runTest("compiler/testData/psi/examples/" + fileName);
    }

    @Test
    public void testAllFilesPresentInExamples() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("AnonymousObjects.kt")
    public void testAnonymousObjects() {
      run("AnonymousObjects.kt");
    }

    @Test
    @TestMetadata("BinaryTree.kt")
    public void testBinaryTree() {
      run("BinaryTree.kt");
    }

    @Test
    @TestMetadata("BitArith.kt")
    public void testBitArith() {
      run("BitArith.kt");
    }

    @Test
    @TestMetadata("Builder.kt")
    public void testBuilder() {
      run("Builder.kt");
    }

    @Test
    @TestMetadata("Color.kt")
    public void testColor() {
      run("Color.kt");
    }

    @Test
    @TestMetadata("FunctionsAndTypes.kt")
    public void testFunctionsAndTypes() {
      run("FunctionsAndTypes.kt");
    }

    @Test
    @TestMetadata("Graph.kt")
    public void testGraph() {
      run("Graph.kt");
    }

    @Test
    @TestMetadata("IPushPop.kt")
    public void testIPushPop() {
      run("IPushPop.kt");
    }

    @Test
    @TestMetadata("LINQ.kt")
    public void testLINQ() {
      run("LINQ.kt");
    }

    @Test
    @TestMetadata("Queue.kt")
    public void testQueue() {
      run("Queue.kt");
    }

    @Test
    @TestMetadata("Stack.kt")
    public void testStack() {
      run("Stack.kt");
    }

    @Test
    @TestMetadata("UnionFind.kt")
    public void testUnionFind() {
      run("UnionFind.kt");
    }

    @Test
    @TestMetadata("UpdateOperation.kt")
    public void testUpdateOperation() {
      run("UpdateOperation.kt");
    }

    @Test
    @TestMetadata("With.kt")
    public void testWith() {
      run("With.kt");
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/array")
    @TestDataPath("$PROJECT_ROOT")
    public class Array {
      private void run(String fileName) {
        runTest("compiler/testData/psi/examples/array/" + fileName);
      }

      @Test
      public void testAllFilesPresentInArray() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/array"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("MutableArray.kt")
      public void testMutableArray() {
        run("MutableArray.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/collections")
    @TestDataPath("$PROJECT_ROOT")
    public class Collections {
      private void run(String fileName) {
        runTest("compiler/testData/psi/examples/collections/" + fileName);
      }

      @Test
      public void testAllFilesPresentInCollections() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/collections"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("ArrayList.kt")
      public void testArrayList() {
        run("ArrayList.kt");
      }

      @Test
      @TestMetadata("HashMap.kt")
      public void testHashMap() {
        run("HashMap.kt");
      }

      @Test
      @TestMetadata("IIterable.kt")
      public void testIIterable() {
        run("IIterable.kt");
      }

      @Test
      @TestMetadata("IIterator.kt")
      public void testIIterator() {
        run("IIterator.kt");
      }

      @Test
      @TestMetadata("IList.kt")
      public void testIList() {
        run("IList.kt");
      }

      @Test
      @TestMetadata("IMutableIterable.kt")
      public void testIMutableIterable() {
        run("IMutableIterable.kt");
      }

      @Test
      @TestMetadata("IMutableIterator.kt")
      public void testIMutableIterator() {
        run("IMutableIterator.kt");
      }

      @Test
      @TestMetadata("IMutableList.kt")
      public void testIMutableList() {
        run("IMutableList.kt");
      }

      @Test
      @TestMetadata("IMutableSet.kt")
      public void testIMutableSet() {
        run("IMutableSet.kt");
      }

      @Test
      @TestMetadata("ISet.kt")
      public void testISet() {
        run("ISet.kt");
      }

      @Test
      @TestMetadata("ISized.kt")
      public void testISized() {
        run("ISized.kt");
      }

      @Test
      @TestMetadata("LinkedList.kt")
      public void testLinkedList() {
        run("LinkedList.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/io")
    @TestDataPath("$PROJECT_ROOT")
    public class Io {
      private void run(String fileName) {
        runTest("compiler/testData/psi/examples/io/" + fileName);
      }

      @Test
      public void testAllFilesPresentInIo() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/io"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("IOSamples.kt")
      public void testIOSamples() {
        run("IOSamples.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/map")
    @TestDataPath("$PROJECT_ROOT")
    public class Map {
      private void run(String fileName) {
        runTest("compiler/testData/psi/examples/map/" + fileName);
      }

      @Test
      public void testAllFilesPresentInMap() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/map"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("IMap.kt")
      public void testIMap() {
        run("IMap.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/priorityqueues")
    @TestDataPath("$PROJECT_ROOT")
    public class Priorityqueues {
      private void run(String fileName) {
        runTest("compiler/testData/psi/examples/priorityqueues/" + fileName);
      }

      @Test
      public void testAllFilesPresentInPriorityqueues() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/priorityqueues"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("BinaryHeap.kt")
      public void testBinaryHeap() {
        run("BinaryHeap.kt");
      }

      @Test
      @TestMetadata("IPriorityQueue.kt")
      public void testIPriorityQueue() {
        run("IPriorityQueue.kt");
      }

      @Test
      @TestMetadata("PriorityQueueAsPushPop.kt")
      public void testPriorityQueueAsPushPop() {
        run("PriorityQueueAsPushPop.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/util")
    @TestDataPath("$PROJECT_ROOT")
    public class Util {
      private void run(String fileName) {
        runTest("compiler/testData/psi/examples/util/" + fileName);
      }

      @Test
      public void testAllFilesPresentInUtil() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/util"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("Comparison.kt")
      public void testComparison() {
        run("Comparison.kt");
      }

      @Test
      @TestMetadata("IComparable.kt")
      public void testIComparable() {
        run("IComparable.kt");
      }
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/functionReceivers")
  @TestDataPath("$PROJECT_ROOT")
  public class FunctionReceivers {
    private void run(String fileName) {
      runTest("compiler/testData/psi/functionReceivers/" + fileName);
    }

    @Test
    public void testAllFilesPresentInFunctionReceivers() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/functionReceivers"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("FunctionTypesWithFunctionReceivers.kt")
    public void testFunctionTypesWithFunctionReceivers() {
      run("FunctionTypesWithFunctionReceivers.kt");
    }

    @Test
    @TestMetadata("FunctionsWithFunctionReceivers.kt")
    public void testFunctionsWithFunctionReceivers() {
      run("FunctionsWithFunctionReceivers.kt");
    }

    @Test
    @TestMetadata("FunctionsWithFunctionReceiversAnnotations.kt")
    public void testFunctionsWithFunctionReceiversAnnotations() {
      run("FunctionsWithFunctionReceiversAnnotations.kt");
    }

    @Test
    @TestMetadata("FunctionsWithFunctionReceiversRecovery.kt")
    public void testFunctionsWithFunctionReceiversRecovery() {
      run("FunctionsWithFunctionReceiversRecovery.kt");
    }

    @Test
    @TestMetadata("PropertiesWithFunctionReceivers.kt")
    public void testPropertiesWithFunctionReceivers() {
      run("PropertiesWithFunctionReceivers.kt");
    }

    @Test
    @TestMetadata("PropertiesWithFunctionReceiversAnnotations.kt")
    public void testPropertiesWithFunctionReceiversAnnotations() {
      run("PropertiesWithFunctionReceiversAnnotations.kt");
    }

    @Test
    @TestMetadata("PropertiesWithFunctionReceiversRecovery.kt")
    public void testPropertiesWithFunctionReceiversRecovery() {
      run("PropertiesWithFunctionReceiversRecovery.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/greatSyntacticShift")
  @TestDataPath("$PROJECT_ROOT")
  public class GreatSyntacticShift {
    private void run(String fileName) {
      runTest("compiler/testData/psi/greatSyntacticShift/" + fileName);
    }

    @Test
    public void testAllFilesPresentInGreatSyntacticShift() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/greatSyntacticShift"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("functionLiterals.kt")
    public void testFunctionLiterals() {
      run("functionLiterals.kt");
    }

    @Test
    @TestMetadata("functionTypes.kt")
    public void testFunctionTypes() {
      run("functionTypes.kt");
    }

    @Test
    @TestMetadata("FunctionTypesAsArguments.kt")
    public void testFunctionTypesAsArguments() {
      run("FunctionTypesAsArguments.kt");
    }

    @Test
    @TestMetadata("nullableTypes.kt")
    public void testNullableTypes() {
      run("nullableTypes.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/kdoc")
  @TestDataPath("$PROJECT_ROOT")
  public class Kdoc {
    private void run(String fileName) {
      runTest("compiler/testData/psi/kdoc/" + fileName);
    }

    @Test
    public void testAllFilesPresentInKdoc() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/kdoc"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("AtTags.kt")
    public void testAtTags() {
      run("AtTags.kt");
    }

    @Test
    @TestMetadata("CodeBlocks.kt")
    public void testCodeBlocks() {
      run("CodeBlocks.kt");
    }

    @Test
    @TestMetadata("DocCommentAtBeginningOfFile1.kt")
    public void testDocCommentAtBeginningOfFile1() {
      run("DocCommentAtBeginningOfFile1.kt");
    }

    @Test
    @TestMetadata("DocCommentAtBeginningOfFile2.kt")
    public void testDocCommentAtBeginningOfFile2() {
      run("DocCommentAtBeginningOfFile2.kt");
    }

    @Test
    @TestMetadata("DocCommentAtBeginningOfFile3.kt")
    public void testDocCommentAtBeginningOfFile3() {
      run("DocCommentAtBeginningOfFile3.kt");
    }

    @Test
    @TestMetadata("DocCommentAtBeginningOfFile4.kt")
    public void testDocCommentAtBeginningOfFile4() {
      run("DocCommentAtBeginningOfFile4.kt");
    }

    @Test
    @TestMetadata("EndOnLeadingAsterisks.kt")
    public void testEndOnLeadingAsterisks() {
      run("EndOnLeadingAsterisks.kt");
    }

    @Test
    @TestMetadata("EndRightAfterText.kt")
    public void testEndRightAfterText() {
      run("EndRightAfterText.kt");
    }

    @Test
    @TestMetadata("Escapes.kt")
    public void testEscapes() {
      run("Escapes.kt");
    }

    @Test
    @TestMetadata("HttpLink.kt")
    public void testHttpLink() {
      run("HttpLink.kt");
    }

    @Test
    @TestMetadata("IdentifiersWithBackticks.kt")
    public void testIdentifiersWithBackticks() {
      run("IdentifiersWithBackticks.kt");
    }

    @Test
    @TestMetadata("Incomplete.kt")
    public void testIncomplete() {
      run("Incomplete.kt");
    }

    @Test
    @TestMetadata("IncompleteCodeBlock.kt")
    public void testIncompleteCodeBlock() {
      run("IncompleteCodeBlock.kt");
    }

    @Test
    @TestMetadata("IncompleteCodeBlockWithoutCode.kt")
    public void testIncompleteCodeBlockWithoutCode() {
      run("IncompleteCodeBlockWithoutCode.kt");
    }

    @Test
    @TestMetadata("IncompleteIndentedCodeBlock.kt")
    public void testIncompleteIndentedCodeBlock() {
      run("IncompleteIndentedCodeBlock.kt");
    }

    @Test
    @TestMetadata("IncompleteIndentedList.kt")
    public void testIncompleteIndentedList() {
      run("IncompleteIndentedList.kt");
    }

    @Test
    @TestMetadata("Markdown.kt")
    public void testMarkdown() {
      run("Markdown.kt");
    }

    @Test
    @TestMetadata("MarkdownCodeBlocks.kt")
    public void testMarkdownCodeBlocks() {
      run("MarkdownCodeBlocks.kt");
    }

    @Test
    @TestMetadata("MarkdownLinkWithError.kt")
    public void testMarkdownLinkWithError() {
      run("MarkdownLinkWithError.kt");
    }

    @Test
    @TestMetadata("MarkdownLinkWithLabel.kt")
    public void testMarkdownLinkWithLabel() {
      run("MarkdownLinkWithLabel.kt");
    }

    @Test
    @TestMetadata("MarkdownQualifiedName.kt")
    public void testMarkdownQualifiedName() {
      run("MarkdownQualifiedName.kt");
    }

    @Test
    @TestMetadata("MultipleAsterisksOnTheSameLine.kt")
    public void testMultipleAsterisksOnTheSameLine() {
      run("MultipleAsterisksOnTheSameLine.kt");
    }

    @Test
    @TestMetadata("NestedLists.kt")
    public void testNestedLists() {
      run("NestedLists.kt");
    }

    @Test
    @TestMetadata("ParamTag.kt")
    public void testParamTag() {
      run("ParamTag.kt");
    }

    @Test
    @TestMetadata("ParamTagAtStart.kt")
    public void testParamTagAtStart() {
      run("ParamTagAtStart.kt");
    }

    @Test
    @TestMetadata("ReturnWithBrackets.kt")
    public void testReturnWithBrackets() {
      run("ReturnWithBrackets.kt");
    }

    @Test
    @TestMetadata("Sections.kt")
    public void testSections() {
      run("Sections.kt");
    }

    @Test
    @TestMetadata("SeeEmpty.kt")
    public void testSeeEmpty() {
      run("SeeEmpty.kt");
    }

    @Test
    @TestMetadata("SeeLink.kt")
    public void testSeeLink() {
      run("SeeLink.kt");
    }

    @Test
    @TestMetadata("Simple.kt")
    public void testSimple() {
      run("Simple.kt");
    }

    @Test
    @TestMetadata("StartCodeBlockAfterTwoOrMoreLineBreaks.kt")
    public void testStartCodeBlockAfterTwoOrMoreLineBreaks() {
      run("StartCodeBlockAfterTwoOrMoreLineBreaks.kt");
    }

    @Test
    @TestMetadata("TextLinkWithNewLine.kt")
    public void testTextLinkWithNewLine() {
      run("TextLinkWithNewLine.kt");
    }

    @Test
    @TestMetadata("TextRightAfterLeadAsterisks.kt")
    public void testTextRightAfterLeadAsterisks() {
      run("TextRightAfterLeadAsterisks.kt");
    }

    @Test
    @TestMetadata("TwoTags.kt")
    public void testTwoTags() {
      run("TwoTags.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/newLabels")
  @TestDataPath("$PROJECT_ROOT")
  public class NewLabels {
    private void run(String fileName) {
      runTest("compiler/testData/psi/newLabels/" + fileName);
    }

    @Test
    public void testAllFilesPresentInNewLabels() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/newLabels"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("basic.kt")
    public void testBasic() {
      run("basic.kt");
    }

    @Test
    @TestMetadata("oldSyntaxExpressions.kt")
    public void testOldSyntaxExpressions() {
      run("oldSyntaxExpressions.kt");
    }

    @Test
    @TestMetadata("recovery.kt")
    public void testRecovery() {
      run("recovery.kt");
    }

    @Test
    @TestMetadata("spaceBeforeLabelReference.kt")
    public void testSpaceBeforeLabelReference() {
      run("spaceBeforeLabelReference.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/operators")
  @TestDataPath("$PROJECT_ROOT")
  public class Operators {
    private void run(String fileName) {
      runTest("compiler/testData/psi/operators/" + fileName);
    }

    @Test
    public void testAllFilesPresentInOperators() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/operators"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("untilOperator.kt")
    public void testUntilOperator() {
      run("untilOperator.kt");
    }

    @Test
    @TestMetadata("untilOperatorDifferentContexts.kt")
    public void testUntilOperatorDifferentContexts() {
      run("untilOperatorDifferentContexts.kt");
    }

    @Test
    @TestMetadata("untilOperatorGenericsClash.kt")
    public void testUntilOperatorGenericsClash() {
      run("untilOperatorGenericsClash.kt");
    }

    @Test
    @TestMetadata("untilOperatorGreater.kt")
    public void testUntilOperatorGreater() {
      run("untilOperatorGreater.kt");
    }

    @Test
    @TestMetadata("untilOperatorWithWhitespace.kt")
    public void testUntilOperatorWithWhitespace() {
      run("untilOperatorWithWhitespace.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/packages")
  @TestDataPath("$PROJECT_ROOT")
  public class Packages {
    private void run(String fileName) {
      runTest("compiler/testData/psi/packages/" + fileName);
    }

    @Test
    public void testAllFilesPresentInPackages() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/packages"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("PackageBlockFirst.kt")
    public void testPackageBlockFirst() {
      run("PackageBlockFirst.kt");
    }

    @Test
    @TestMetadata("PackageLeadingDotDoubleID.kt")
    public void testPackageLeadingDotDoubleID() {
      run("PackageLeadingDotDoubleID.kt");
    }

    @Test
    @TestMetadata("PackageLongNameBetweenDots.kt")
    public void testPackageLongNameBetweenDots() {
      run("PackageLongNameBetweenDots.kt");
    }

    @Test
    @TestMetadata("PackageLongNameDoubleID.kt")
    public void testPackageLongNameDoubleID() {
      run("PackageLongNameDoubleID.kt");
    }

    @Test
    @TestMetadata("PackageLongNameLeadingDot.kt")
    public void testPackageLongNameLeadingDot() {
      run("PackageLongNameLeadingDot.kt");
    }

    @Test
    @TestMetadata("PackageLongNameLeadingDoubleDot.kt")
    public void testPackageLongNameLeadingDoubleDot() {
      run("PackageLongNameLeadingDoubleDot.kt");
    }

    @Test
    @TestMetadata("PackageModifiers.kt")
    public void testPackageModifiers() {
      run("PackageModifiers.kt");
    }

    @Test
    @TestMetadata("PackageNameDoubleDot.kt")
    public void testPackageNameDoubleDot() {
      run("PackageNameDoubleDot.kt");
    }

    @Test
    @TestMetadata("PackageNameJustDot.kt")
    public void testPackageNameJustDot() {
      run("PackageNameJustDot.kt");
    }

    @Test
    @TestMetadata("PackageSimpleNameLeadingDot.kt")
    public void testPackageSimpleNameLeadingDot() {
      run("PackageSimpleNameLeadingDot.kt");
    }

    @Test
    @TestMetadata("PackageSimpleNameLeadingDoubleDot.kt")
    public void testPackageSimpleNameLeadingDoubleDot() {
      run("PackageSimpleNameLeadingDoubleDot.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/platformTypesRecovery")
  @TestDataPath("$PROJECT_ROOT")
  public class PlatformTypesRecovery {
    private void run(String fileName) {
      runTest("compiler/testData/psi/platformTypesRecovery/" + fileName);
    }

    @Test
    public void testAllFilesPresentInPlatformTypesRecovery() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/platformTypesRecovery"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("Array.kt")
    public void testArray() {
      run("Array.kt");
    }

    @Test
    @TestMetadata("BeforeDot.kt")
    public void testBeforeDot() {
      run("BeforeDot.kt");
    }

    @Test
    @TestMetadata("Collections.kt")
    public void testCollections() {
      run("Collections.kt");
    }

    @Test
    @TestMetadata("FunctionsNotPlatform.kt")
    public void testFunctionsNotPlatform() {
      run("FunctionsNotPlatform.kt");
    }

    @Test
    @TestMetadata("MapEntry.kt")
    public void testMapEntry() {
      run("MapEntry.kt");
    }

    @Test
    @TestMetadata("ParenthesizedNotPlatform.kt")
    public void testParenthesizedNotPlatform() {
      run("ParenthesizedNotPlatform.kt");
    }

    @Test
    @TestMetadata("Qualified.kt")
    public void testQualified() {
      run("Qualified.kt");
    }

    @Test
    @TestMetadata("QualifiedCollections.kt")
    public void testQualifiedCollections() {
      run("QualifiedCollections.kt");
    }

    @Test
    @TestMetadata("Simple.kt")
    public void testSimple() {
      run("Simple.kt");
    }

    @Test
    @TestMetadata("WrongWordInParentheses.kt")
    public void testWrongWordInParentheses() {
      run("WrongWordInParentheses.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/primaryConstructor")
  @TestDataPath("$PROJECT_ROOT")
  public class PrimaryConstructor {
    private void run(String fileName) {
      runTest("compiler/testData/psi/primaryConstructor/" + fileName);
    }

    @Test
    public void testAllFilesPresentInPrimaryConstructor() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/primaryConstructor"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("local.kt")
    public void testLocal() {
      run("local.kt");
    }

    @Test
    @TestMetadata("nestedClassAmbiguity.kt")
    public void testNestedClassAmbiguity() {
      run("nestedClassAmbiguity.kt");
    }

    @Test
    @TestMetadata("recovery.kt")
    public void testRecovery() {
      run("recovery.kt");
    }

    @Test
    @TestMetadata("recoveryNestedClassAmbiguity.kt")
    public void testRecoveryNestedClassAmbiguity() {
      run("recoveryNestedClassAmbiguity.kt");
    }

    @Test
    @TestMetadata("valid.kt")
    public void testValid() {
      run("valid.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/propertyBackingField")
  @TestDataPath("$PROJECT_ROOT")
  public class PropertyBackingField {
    private void run(String fileName) {
      runTest("compiler/testData/psi/propertyBackingField/" + fileName);
    }

    @Test
    public void testAllFilesPresentInPropertyBackingField() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/propertyBackingField"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("annotationClass.kt")
    public void testAnnotationClass() {
      run("annotationClass.kt");
    }

    @Test
    @TestMetadata("backingFieldComment.kt")
    public void testBackingFieldComment() {
      run("backingFieldComment.kt");
    }

    @Test
    @TestMetadata("explicitBackingField.kt")
    public void testExplicitBackingField() {
      run("explicitBackingField.kt");
    }

    @Test
    @TestMetadata("properties.kt")
    public void testProperties() {
      run("properties.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/propertyDelegate")
  @TestDataPath("$PROJECT_ROOT")
  public class PropertyDelegate {
    private void run(String fileName) {
      runTest("compiler/testData/psi/propertyDelegate/" + fileName);
    }

    @Test
    public void testAllFilesPresentInPropertyDelegate() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/propertyDelegate"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("BracketsInDelegate.kt")
    public void testBracketsInDelegate() {
      run("BracketsInDelegate.kt");
    }

    @Test
    @TestMetadata("DelegateAndInitializer.kt")
    public void testDelegateAndInitializer() {
      run("DelegateAndInitializer.kt");
    }

    @Test
    @TestMetadata("GetterInSameLine.kt")
    public void testGetterInSameLine() {
      run("GetterInSameLine.kt");
    }

    @Test
    @TestMetadata("LocalProperty.kt")
    public void testLocalProperty() {
      run("LocalProperty.kt");
    }

    @Test
    @TestMetadata("OnlyBy.kt")
    public void testOnlyBy() {
      run("OnlyBy.kt");
    }

    @Test
    @TestMetadata("PropertyInClass.kt")
    public void testPropertyInClass() {
      run("PropertyInClass.kt");
    }

    @Test
    @TestMetadata("PropertyWithGetter.kt")
    public void testPropertyWithGetter() {
      run("PropertyWithGetter.kt");
    }

    @Test
    @TestMetadata("PropertyWithInitializer.kt")
    public void testPropertyWithInitializer() {
      run("PropertyWithInitializer.kt");
    }

    @Test
    @TestMetadata("PropertyWithoutTypeRef.kt")
    public void testPropertyWithoutTypeRef() {
      run("PropertyWithoutTypeRef.kt");
    }

    @Test
    @TestMetadata("TopLevelProperty.kt")
    public void testTopLevelProperty() {
      run("TopLevelProperty.kt");
    }

    @Test
    @TestMetadata("TwoProperties.kt")
    public void testTwoProperties() {
      run("TwoProperties.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/recovery")
  @TestDataPath("$PROJECT_ROOT")
  public class Recovery {
    private void run(String fileName) {
      runTest("compiler/testData/psi/recovery/" + fileName);
    }

    @Test
    @TestMetadata("AbsentLeftHandSide.kt")
    public void testAbsentLeftHandSide() {
      run("AbsentLeftHandSide.kt");
    }

    @Test
    public void testAllFilesPresentInRecovery() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("BareVal.kt")
    public void testBareVal() {
      run("BareVal.kt");
    }

    @Test
    @TestMetadata("BrokenFunctionSuperType.kt")
    public void testBrokenFunctionSuperType() {
      run("BrokenFunctionSuperType.kt");
    }

    @Test
    @TestMetadata("CatchKeywordRBrace.kt")
    public void testCatchKeywordRBrace() {
      run("CatchKeywordRBrace.kt");
    }

    @Test
    @TestMetadata("CloseBraceAtTopLevel.kt")
    public void testCloseBraceAtTopLevel() {
      run("CloseBraceAtTopLevel.kt");
    }

    @Test
    @TestMetadata("DeclarationAfterDotSelectorExpected.kt")
    public void testDeclarationAfterDotSelectorExpected() {
      run("DeclarationAfterDotSelectorExpected.kt");
    }

    @Test
    @TestMetadata("DeclarationAfterIncompleteElvis.kt")
    public void testDeclarationAfterIncompleteElvis() {
      run("DeclarationAfterIncompleteElvis.kt");
    }

    @Test
    @TestMetadata("DoWhileWithEmptyCondition.kt")
    public void testDoWhileWithEmptyCondition() {
      run("DoWhileWithEmptyCondition.kt");
    }

    @Test
    @TestMetadata("DoWhileWithoutLPar.kt")
    public void testDoWhileWithoutLPar() {
      run("DoWhileWithoutLPar.kt");
    }

    @Test
    @TestMetadata("enumWthoutClass.kt")
    public void testEnumWthoutClass() {
      run("enumWthoutClass.kt");
    }

    @Test
    @TestMetadata("ForEmptyParentheses.kt")
    public void testForEmptyParentheses() {
      run("ForEmptyParentheses.kt");
    }

    @Test
    @TestMetadata("ForEmptyWithoutBody.kt")
    public void testForEmptyWithoutBody() {
      run("ForEmptyWithoutBody.kt");
    }

    @Test
    @TestMetadata("ForNoBodyBeforeRBrace.kt")
    public void testForNoBodyBeforeRBrace() {
      run("ForNoBodyBeforeRBrace.kt");
    }

    @Test
    @TestMetadata("ForRecovery.kt")
    public void testForRecovery() {
      run("ForRecovery.kt");
    }

    @Test
    @TestMetadata("ForWithOnlyOneLParInEOF.kt")
    public void testForWithOnlyOneLParInEOF() {
      run("ForWithOnlyOneLParInEOF.kt");
    }

    @Test
    @TestMetadata("ForWithoutBodyInEOF.kt")
    public void testForWithoutBodyInEOF() {
      run("ForWithoutBodyInEOF.kt");
    }

    @Test
    @TestMetadata("ForWithoutLPar.kt")
    public void testForWithoutLPar() {
      run("ForWithoutLPar.kt");
    }

    @Test
    @TestMetadata("ForWithoutLParInEOF.kt")
    public void testForWithoutLParInEOF() {
      run("ForWithoutLParInEOF.kt");
    }

    @Test
    @TestMetadata("ForWithoutParamButWithRange.kt")
    public void testForWithoutParamButWithRange() {
      run("ForWithoutParamButWithRange.kt");
    }

    @Test
    @TestMetadata("ForWithoutRange.kt")
    public void testForWithoutRange() {
      run("ForWithoutRange.kt");
    }

    @Test
    @TestMetadata("FunFun.kt")
    public void testFunFun() {
      run("FunFun.kt");
    }

    @Test
    @TestMetadata("IfKeywordRBrace.kt")
    public void testIfKeywordRBrace() {
      run("IfKeywordRBrace.kt");
    }

    @Test
    @TestMetadata("IfWithEmptyCondition.kt")
    public void testIfWithEmptyCondition() {
      run("IfWithEmptyCondition.kt");
    }

    @Test
    @TestMetadata("IfWithoutLPar.kt")
    public void testIfWithoutLPar() {
      run("IfWithoutLPar.kt");
    }

    @Test
    @TestMetadata("ImportRecovery.kt")
    public void testImportRecovery() {
      run("ImportRecovery.kt");
    }

    @Test
    @TestMetadata("importsWithConflict.kt")
    public void testImportsWithConflict() {
      run("importsWithConflict.kt");
    }

    @Test
    @TestMetadata("IncompleteAccessor1.kt")
    public void testIncompleteAccessor1() {
      run("IncompleteAccessor1.kt");
    }

    @Test
    @TestMetadata("IncompleteAccessor2.kt")
    public void testIncompleteAccessor2() {
      run("IncompleteAccessor2.kt");
    }

    @Test
    @TestMetadata("IncompleteClassDeclaration.kt")
    public void testIncompleteClassDeclaration() {
      run("IncompleteClassDeclaration.kt");
    }

    @Test
    @TestMetadata("IncompleteClassTypeParameters.kt")
    public void testIncompleteClassTypeParameters() {
      run("IncompleteClassTypeParameters.kt");
    }

    @Test
    @TestMetadata("IncompleteForRBrace.kt")
    public void testIncompleteForRBrace() {
      run("IncompleteForRBrace.kt");
    }

    @Test
    @TestMetadata("IncompleteFun.kt")
    public void testIncompleteFun() {
      run("IncompleteFun.kt");
    }

    @Test
    @TestMetadata("IncompleteFunDeclaration.kt")
    public void testIncompleteFunDeclaration() {
      run("IncompleteFunDeclaration.kt");
    }

    @Test
    @TestMetadata("IncompleteFunTypeParameters.kt")
    public void testIncompleteFunTypeParameters() {
      run("IncompleteFunTypeParameters.kt");
    }

    @Test
    @TestMetadata("IncompleteTypeParameters.kt")
    public void testIncompleteTypeParameters() {
      run("IncompleteTypeParameters.kt");
    }

    @Test
    @TestMetadata("IncompleteTypeRefWithPackageKeyword.kt")
    public void testIncompleteTypeRefWithPackageKeyword() {
      run("IncompleteTypeRefWithPackageKeyword.kt");
    }

    @Test
    @TestMetadata("IncompleteValTypeParameters.kt")
    public void testIncompleteValTypeParameters() {
      run("IncompleteValTypeParameters.kt");
    }

    @Test
    @TestMetadata("IncompleteWhenElse.kt")
    public void testIncompleteWhenElse() {
      run("IncompleteWhenElse.kt");
    }

    @Test
    @TestMetadata("IncompleteWhere.kt")
    public void testIncompleteWhere() {
      run("IncompleteWhere.kt");
    }

    @Test
    @TestMetadata("IncompleteWhere2.kt")
    public void testIncompleteWhere2() {
      run("IncompleteWhere2.kt");
    }

    @Test
    @TestMetadata("initRecovery.kt")
    public void testInitRecovery() {
      run("initRecovery.kt");
    }

    @Test
    @TestMetadata("InterfaceInExpressionPosition.kt")
    public void testInterfaceInExpressionPosition() {
      run("InterfaceInExpressionPosition.kt");
    }

    @Test
    @TestMetadata("InvalidCharAfterPropertyName.kt")
    public void testInvalidCharAfterPropertyName() {
      run("InvalidCharAfterPropertyName.kt");
    }

    @Test
    @TestMetadata("InvalidCharInSingleLineLambda.kt")
    public void testInvalidCharInSingleLineLambda() {
      run("InvalidCharInSingleLineLambda.kt");
    }

    @Test
    @TestMetadata("kt2172.kt")
    public void testKt2172() {
      run("kt2172.kt");
    }

    @Test
    @TestMetadata("kt24158.kt")
    public void testKt24158() {
      run("kt24158.kt");
    }

    @Test
    @TestMetadata("kt5102.kt")
    public void testKt5102() {
      run("kt5102.kt");
    }

    @Test
    @TestMetadata("lambdaExpressionInString_1.kt")
    public void testLambdaExpressionInString_1() {
      run("lambdaExpressionInString_1.kt");
    }

    @Test
    @TestMetadata("lambdaExpressionInString_2.kt")
    public void testLambdaExpressionInString_2() {
      run("lambdaExpressionInString_2.kt");
    }

    @Test
    @TestMetadata("MissingCommaInConstructorValueParameterList.kt")
    public void testMissingCommaInConstructorValueParameterList() {
      run("MissingCommaInConstructorValueParameterList.kt");
    }

    @Test
    @TestMetadata("MissingCommaInValueArgumentList.kt")
    public void testMissingCommaInValueArgumentList() {
      run("MissingCommaInValueArgumentList.kt");
    }

    @Test
    @TestMetadata("MissingCommaInValueParameterList.kt")
    public void testMissingCommaInValueParameterList() {
      run("MissingCommaInValueParameterList.kt");
    }

    @Test
    @TestMetadata("MissingCommaInValueParameterListWithValOrVar.kt")
    public void testMissingCommaInValueParameterListWithValOrVar() {
      run("MissingCommaInValueParameterListWithValOrVar.kt");
    }

    @Test
    @TestMetadata("NoArrowInWhen.kt")
    public void testNoArrowInWhen() {
      run("NoArrowInWhen.kt");
    }

    @Test
    @TestMetadata("NoGTInTypeArguments.kt")
    public void testNoGTInTypeArguments() {
      run("NoGTInTypeArguments.kt");
    }

    @Test
    @TestMetadata("PackageNewLineRecovery.kt")
    public void testPackageNewLineRecovery() {
      run("PackageNewLineRecovery.kt");
    }

    @Test
    @TestMetadata("PackageRecovery.kt")
    public void testPackageRecovery() {
      run("PackageRecovery.kt");
    }

    @Test
    @TestMetadata("SameLineStatementRecovery.kt")
    public void testSameLineStatementRecovery() {
      run("SameLineStatementRecovery.kt");
    }

    @Test
    @TestMetadata("UnfinishedExtension.kt")
    public void testUnfinishedExtension() {
      run("UnfinishedExtension.kt");
    }

    @Test
    @TestMetadata("ValNoName.kt")
    public void testValNoName() {
      run("ValNoName.kt");
    }

    @Test
    @TestMetadata("ValWithNoNameBeforeNextDeclarationWithModifiers.kt")
    public void testValWithNoNameBeforeNextDeclarationWithModifiers() {
      run("ValWithNoNameBeforeNextDeclarationWithModifiers.kt");
    }

    @Test
    @TestMetadata("ValWithNoNameInBlock.kt")
    public void testValWithNoNameInBlock() {
      run("ValWithNoNameInBlock.kt");
    }

    @Test
    @TestMetadata("ValueParameterNoTypeRecovery.kt")
    public void testValueParameterNoTypeRecovery() {
      run("ValueParameterNoTypeRecovery.kt");
    }

    @Test
    @TestMetadata("valueParameterRecovery.kt")
    public void testValueParameterRecovery() {
      run("valueParameterRecovery.kt");
    }

    @Test
    @TestMetadata("valueParameterRecoveryWithTypes.kt")
    public void testValueParameterRecoveryWithTypes() {
      run("valueParameterRecoveryWithTypes.kt");
    }

    @Test
    @TestMetadata("WhenWithoutBraces.kt")
    public void testWhenWithoutBraces() {
      run("WhenWithoutBraces.kt");
    }

    @Test
    @TestMetadata("WhileWithEmptyCondition.kt")
    public void testWhileWithEmptyCondition() {
      run("WhileWithEmptyCondition.kt");
    }

    @Test
    @TestMetadata("WhileWithoutLPar.kt")
    public void testWhileWithoutLPar() {
      run("WhileWithoutLPar.kt");
    }

    @Test
    @TestMetadata("WithWithoutInAndMultideclaration.kt")
    public void testWithWithoutInAndMultideclaration() {
      run("WithWithoutInAndMultideclaration.kt");
    }

    @Nested
    @TestMetadata("compiler/testData/psi/recovery/binaryExpression")
    @TestDataPath("$PROJECT_ROOT")
    public class BinaryExpression {
      private void run(String fileName) {
        runTest("compiler/testData/psi/recovery/binaryExpression/" + fileName);
      }

      @Test
      public void testAllFilesPresentInBinaryExpression() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/binaryExpression"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("IsAndSubsequentExpressions.kt")
      public void testIsAndSubsequentExpressions() {
        run("IsAndSubsequentExpressions.kt");
      }

      @Test
      @TestMetadata("IsExpressionComplex.kt")
      public void testIsExpressionComplex() {
        run("IsExpressionComplex.kt");
      }

      @Test
      @TestMetadata("NoHigherPrecedenceAfterIs.kt")
      public void testNoHigherPrecedenceAfterIs() {
        run("NoHigherPrecedenceAfterIs.kt");
      }

      @Test
      @TestMetadata("SoftModifierAsInfixFunction.kt")
      public void testSoftModifierAsInfixFunction() {
        run("SoftModifierAsInfixFunction.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/recovery/objects")
    @TestDataPath("$PROJECT_ROOT")
    public class Objects {
      private void run(String fileName) {
        runTest("compiler/testData/psi/recovery/objects/" + fileName);
      }

      @Test
      public void testAllFilesPresentInObjects() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/objects"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Nested
      @TestMetadata("compiler/testData/psi/recovery/objects/declarations")
      @TestDataPath("$PROJECT_ROOT")
      public class Declarations {
        private void run(String fileName) {
          runTest("compiler/testData/psi/recovery/objects/declarations/" + fileName);
        }

        @Test
        public void testAllFilesPresentInDeclarations() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/objects/declarations"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("ConstructorModifiers.kt")
        public void testConstructorModifiers() {
          run("ConstructorModifiers.kt");
        }

        @Test
        @TestMetadata("EmptyParentheses.kt")
        public void testEmptyParentheses() {
          run("EmptyParentheses.kt");
        }

        @Test
        @TestMetadata("Everything.kt")
        public void testEverything() {
          run("Everything.kt");
        }

        @Test
        @TestMetadata("FollowedByModifiers.kt")
        public void testFollowedByModifiers() {
          run("FollowedByModifiers.kt");
        }

        @Test
        @TestMetadata("ParametersInParentheses.kt")
        public void testParametersInParentheses() {
          run("ParametersInParentheses.kt");
        }

        @Test
        @TestMetadata("TypeParametersAndParentheses.kt")
        public void testTypeParametersAndParentheses() {
          run("TypeParametersAndParentheses.kt");
        }

        @Test
        @TestMetadata("TypeParameterss.kt")
        public void testTypeParameterss() {
          run("TypeParameterss.kt");
        }

        @Test
        @TestMetadata("Where.kt")
        public void testWhere() {
          run("Where.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/recovery/objects/expressions")
      @TestDataPath("$PROJECT_ROOT")
      public class Expressions {
        private void run(String fileName) {
          runTest("compiler/testData/psi/recovery/objects/expressions/" + fileName);
        }

        @Test
        public void testAllFilesPresentInExpressions() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/objects/expressions"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("ConstructorModifiers.kt")
        public void testConstructorModifiers() {
          run("ConstructorModifiers.kt");
        }

        @Test
        @TestMetadata("ConstructorModifiersAndName.kt")
        public void testConstructorModifiersAndName() {
          run("ConstructorModifiersAndName.kt");
        }

        @Test
        @TestMetadata("EmptyParentheses.kt")
        public void testEmptyParentheses() {
          run("EmptyParentheses.kt");
        }

        @Test
        @TestMetadata("Everything.kt")
        public void testEverything() {
          run("Everything.kt");
        }

        @Test
        @TestMetadata("InFunction.kt")
        public void testInFunction() {
          run("InFunction.kt");
        }

        @Test
        @TestMetadata("ParametersInParentheses.kt")
        public void testParametersInParentheses() {
          run("ParametersInParentheses.kt");
        }

        @Test
        @TestMetadata("TypeParametersAndParentheses.kt")
        public void testTypeParametersAndParentheses() {
          run("TypeParametersAndParentheses.kt");
        }

        @Test
        @TestMetadata("TypeParameterss.kt")
        public void testTypeParameterss() {
          run("TypeParameterss.kt");
        }

        @Test
        @TestMetadata("Where.kt")
        public void testWhere() {
          run("Where.kt");
        }
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/recovery/qualifiedExpression")
    @TestDataPath("$PROJECT_ROOT")
    public class QualifiedExpression {
      private void run(String fileName) {
        runTest("compiler/testData/psi/recovery/qualifiedExpression/" + fileName);
      }

      @Test
      public void testAllFilesPresentInQualifiedExpression() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/qualifiedExpression"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("noQualifiedExpression.kt")
      public void testNoQualifiedExpression() {
        run("noQualifiedExpression.kt");
      }

      @Test
      @TestMetadata("noSafeQualifiedExpression.kt")
      public void testNoSafeQualifiedExpression() {
        run("noSafeQualifiedExpression.kt");
      }

      @Test
      @TestMetadata("qualifiedExpressionWithSelector.kt")
      public void testQualifiedExpressionWithSelector() {
        run("qualifiedExpressionWithSelector.kt");
      }

      @Test
      @TestMetadata("qualifiedExpressionWithoutSelector.kt")
      public void testQualifiedExpressionWithoutSelector() {
        run("qualifiedExpressionWithoutSelector.kt");
      }

      @Test
      @TestMetadata("safeQualifiedExpressionWithSelector.kt")
      public void testSafeQualifiedExpressionWithSelector() {
        run("safeQualifiedExpressionWithSelector.kt");
      }

      @Test
      @TestMetadata("safeQualifiedExpressionWithoutSelector.kt")
      public void testSafeQualifiedExpressionWithoutSelector() {
        run("safeQualifiedExpressionWithoutSelector.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/recovery/unnamedParameter")
    @TestDataPath("$PROJECT_ROOT")
    public class UnnamedParameter {
      private void run(String fileName) {
        runTest("compiler/testData/psi/recovery/unnamedParameter/" + fileName);
      }

      @Test
      public void testAllFilesPresentInUnnamedParameter() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/unnamedParameter"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("firstInFunction.kt")
      public void testFirstInFunction() {
        run("firstInFunction.kt");
      }

      @Test
      @TestMetadata("firstInFunctionalType.kt")
      public void testFirstInFunctionalType() {
        run("firstInFunctionalType.kt");
      }

      @Test
      @TestMetadata("firstInLambda.kt")
      public void testFirstInLambda() {
        run("firstInLambda.kt");
      }

      @Test
      @TestMetadata("firstInPrimaryConstructor.kt")
      public void testFirstInPrimaryConstructor() {
        run("firstInPrimaryConstructor.kt");
      }

      @Test
      @TestMetadata("firstInSecondaryConstructor.kt")
      public void testFirstInSecondaryConstructor() {
        run("firstInSecondaryConstructor.kt");
      }

      @Test
      @TestMetadata("firstInSetter.kt")
      public void testFirstInSetter() {
        run("firstInSetter.kt");
      }

      @Test
      @TestMetadata("secondInFunction.kt")
      public void testSecondInFunction() {
        run("secondInFunction.kt");
      }

      @Test
      @TestMetadata("secondInFunctionalType.kt")
      public void testSecondInFunctionalType() {
        run("secondInFunctionalType.kt");
      }

      @Test
      @TestMetadata("secondInLambda.kt")
      public void testSecondInLambda() {
        run("secondInLambda.kt");
      }

      @Test
      @TestMetadata("secondInPrimaryConstructor.kt")
      public void testSecondInPrimaryConstructor() {
        run("secondInPrimaryConstructor.kt");
      }

      @Test
      @TestMetadata("secondInSecondaryConstructor.kt")
      public void testSecondInSecondaryConstructor() {
        run("secondInSecondaryConstructor.kt");
      }
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/script")
  @TestDataPath("$PROJECT_ROOT")
  public class Script {
    private void run(String fileName) {
      runTest("compiler/testData/psi/script/" + fileName);
    }

    @Test
    public void testAllFilesPresentInScript() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/script"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/secondaryConstructors")
  @TestDataPath("$PROJECT_ROOT")
  public class SecondaryConstructors {
    private void run(String fileName) {
      runTest("compiler/testData/psi/secondaryConstructors/" + fileName);
    }

    @Test
    public void testAllFilesPresentInSecondaryConstructors() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/secondaryConstructors"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("anonymousInitializer.kt")
    public void testAnonymousInitializer() {
      run("anonymousInitializer.kt");
    }

    @Test
    @TestMetadata("basic.kt")
    public void testBasic() {
      run("basic.kt");
    }

    @Test
    @TestMetadata("emptyBody.kt")
    public void testEmptyBody() {
      run("emptyBody.kt");
    }

    @Test
    @TestMetadata("enumParsing.kt")
    public void testEnumParsing() {
      run("enumParsing.kt");
    }

    @Test
    @TestMetadata("recoveryEmptyDelegationType.kt")
    public void testRecoveryEmptyDelegationType() {
      run("recoveryEmptyDelegationType.kt");
    }

    @Test
    @TestMetadata("recoveryJustConstructorKeyword.kt")
    public void testRecoveryJustConstructorKeyword() {
      run("recoveryJustConstructorKeyword.kt");
    }

    @Test
    @TestMetadata("recoveryJustConstructorKeywordSameLineBrace.kt")
    public void testRecoveryJustConstructorKeywordSameLineBrace() {
      run("recoveryJustConstructorKeywordSameLineBrace.kt");
    }

    @Test
    @TestMetadata("recoveryNoDelegationCallAfterColon.kt")
    public void testRecoveryNoDelegationCallAfterColon() {
      run("recoveryNoDelegationCallAfterColon.kt");
    }

    @Test
    @TestMetadata("recoveryWithoutBodyWrongDelegationName.kt")
    public void testRecoveryWithoutBodyWrongDelegationName() {
      run("recoveryWithoutBodyWrongDelegationName.kt");
    }

    @Test
    @TestMetadata("recoveryWithoutParameterList.kt")
    public void testRecoveryWithoutParameterList() {
      run("recoveryWithoutParameterList.kt");
    }

    @Test
    @TestMetadata("recoveryWrongDelegationName.kt")
    public void testRecoveryWrongDelegationName() {
      run("recoveryWrongDelegationName.kt");
    }

    @Test
    @TestMetadata("secondaryConstructors.kt")
    public void testSecondaryConstructors() {
      run("secondaryConstructors.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/stringTemplates")
  @TestDataPath("$PROJECT_ROOT")
  public class StringTemplates {
    private void run(String fileName) {
      runTest("compiler/testData/psi/stringTemplates/" + fileName);
    }

    @Test
    public void testAllFilesPresentInStringTemplates() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/stringTemplates"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("IncorrectMultiDollarInterpolationCode.kt")
    public void testIncorrectMultiDollarInterpolationCode() {
      run("IncorrectMultiDollarInterpolationCode.kt");
    }

    @Test
    @TestMetadata("IncorrectPaddedMultiDollarInterpolationCode.kt")
    public void testIncorrectPaddedMultiDollarInterpolationCode() {
      run("IncorrectPaddedMultiDollarInterpolationCode.kt");
    }

    @Test
    @TestMetadata("MultiDollarBacktick.kt")
    public void testMultiDollarBacktick() {
      run("MultiDollarBacktick.kt");
    }

    @Test
    @TestMetadata("RawStringsWithManyQuotes.kt")
    public void testRawStringsWithManyQuotes() {
      run("RawStringsWithManyQuotes.kt");
    }

    @Test
    @TestMetadata("StringTemplateWithTryWithoutBlockInLongEntry.kt")
    public void testStringTemplateWithTryWithoutBlockInLongEntry() {
      run("StringTemplateWithTryWithoutBlockInLongEntry.kt");
    }

    @Test
    @TestMetadata("StringTemplateWithTryWithoutBlockInShortEntry.kt")
    public void testStringTemplateWithTryWithoutBlockInShortEntry() {
      run("StringTemplateWithTryWithoutBlockInShortEntry.kt");
    }
  }
}
